" .vimrc
" Author: Steve Losh <steve@stevelosh.com>
" Modifier: Lowe Thiderman <lowe.thiderman@gmail.com>
" Source: http://bitbucket.org/sjl/dotfiles/src/tip/vim/
"
" This file was respectfully stolen from Steve Losh. It has been modified to
" contain some of the configs I had, but 90% of the file is still in the magic.

" For now. Endwise and smartinput clash on imap <cr>. Rather, smartinput
" refuses, since endwise was there first.
let g:loaded_endwise = 1

" Preamble {{{

filetype off
call pathogen#infect()
filetype plugin indent on
set nocompatible

" }}}
" Basic options {{{

" Basic settings {{{

set encoding=utf-8
set modelines=5
set autoindent
set showmode
set showcmd
set hidden
set novisualbell
set t_vb=
set updatetime=1000
set ttyfast
set ruler
set backspace=indent,eol,start
set nonumber
if exists('+relativenumber')
  set norelativenumber
endif
set laststatus=2
set history=1000
if exists('+undofile')
  set undofile
  set undoreload=10000
endif
set list
set listchars=tab:▸\ ,trail:¬,extends:❯,precedes:❮
" set shell=/bin/bash\ --login
set lazyredraw
set matchtime=3
set showbreak=↪
set splitbelow
set splitright
set fillchars=diff:⣿,vert:│
set autowrite
set autoread
set shiftround
set title
set linebreak
set dictionary=/usr/share/dict/words
set spellfile=~/.vim/custom-dictionary.utf-8.add
if exists('+colorcolumn')
  set colorcolumn=+1
endif

" Don't try to highlight lines longer than 800 characters.
set synmaxcol=800

" Time out on key codes but not mappings.
" Basically this makes terminal Vim work sanely.
set notimeout
set ttimeout
set ttimeoutlen=10

" Make Vim able to edit crontab files again.
set backupskip=/tmp/*,/private/tmp/*"

" Better Completion
set complete=.,w,b,u,t
set completeopt=longest,menuone,preview

" Save when losing focus
au FocusLost * :silent! wall

" Resize splits when the window is resized
au VimResized * :wincmd =

" }}}
" cpoptions+=J, dammit {{{

" Something occasionally removes this.  If I manage to find it I'm going to
" comment out the line and replace all its characters with 'FUCK'.
augroup twospace
  au!
  au BufRead * :set cpoptions+=J
augroup END

" }}}
" Autosave {{{

" Save the file on delays. Can be toggled by letting/unletting g:no_autosave
function! AutoSave()
  if exists('g:no_autosave') || &modified == 0
    return
  endif

  " call KillTrailingWhitespace()
  silent! wa
endfunction

augroup autosave
  au!
  au InsertLeave * call AutoSave()
  au CursorHold * call AutoSave()
  au CursorHoldI * call AutoSave()
augroup END

" }}}
" Kill trailing whitespace {{{

function! KillTrailingWhitespace(...)
  let pos=getpos('.')
  silent! %s/\s\+$//e
  if a:0
    " If arguments are given, kill trailing lines at the bottom of the file
    silent! %s/\v\n+%$//e
  endif
  call setpos('.',pos)
endfunction

augroup trailing
  au!
  au BufWritePre * call KillTrailingWhitespace(1)
augroup END

" }}}
" Wildmenu completion {{{

set wildmenu
set wildmode=list:longest

set wildignore+=.hg,.git,.svn                          " Version control
set wildignore+=*.aux,*.out,*.toc                      " LaTeX intermediate files
set wildignore+=*.jpg,*.bmp,*.gif,*.png,*.jpeg         " binary images
set wildignore+=*.o,*.obj,*.exe,*.dll,*.manifest       " compiled object files
set wildignore+=*.spl                                  " compiled spelling word lists
set wildignore+=*.sw?                                  " Vim swap files
set wildignore+=*.DS_Store                             " OSX bullshit
set wildignore+=*.luac                                 " Lua byte code
set wildignore+=migrations                             " Django migrations
set wildignore+=*.mo                                   " Django i18n
set wildignore+=*.pyc,*__pycache__*                    " Python byte code
set wildignore+=*.orig                                 " Merge resolution files

" }}}
" Line Return {{{

" Make sure Vim returns to the same line when you reopen a file.
" Thanks, Amit
augroup line_return
  au!
  au BufReadPost *
    \ if line("'\"") > 0 && line("'\"") <= line("$") |
    \   execute 'normal! g`"zvzz' |
    \ endif
augroup END

" }}}
" Tabs, spaces, wrapping {{{

set tabstop=8
set shiftwidth=2
set softtabstop=2
set expandtab
set nowrap
set textwidth=80
set formatoptions=qrn1tco
if v:version >= 703
  set formatoptions+=j
endif
if exists('+colorcolumn')
  set colorcolumn=+1
endif

" }}}
" Backups {{{

set backup            " enable backups
set noswapfile          " It's 2012, Vim.

set viminfo='100,<50,s10,h,!,n~/.cache/vim/viminfo
if exists('+undodir')
  set undodir=~/.cache/vim/undo//   " undo files
endif
set backupdir=~/.cache/vim/backup// " backups
set directory=~/.cache/vim/swap//   " swap files

" }}}
" Leader {{{

let mapleader = ","
let maplocalleader = "\\"

" }}}
" Color scheme {{{

syntax on
set background=dark
let g:badwolf_tabline = 2
let g:badwolf_html_link_underline = 0
let g:badwold_darkgutter = 1
colorscheme badwolf

" Reload the colorscheme whenever we write the file.
augroup color_badwolf_dev
  au!
  au BufWritePost badwolf.vim color badwolf
augroup END

" Highlight VCS conflict markers
match ErrorMsg '^\(<\|=\|>\)\{7\}\([^=].\+\)\?$'

" }}}

" }}}
" Convenience mappings {{{

" Kill window
nnoremap K :q<cr>

" Man
nnoremap M K

" Toggle line numbers
nnoremap <leader>n :setlocal number!<cr>

" Sort lines
" nnoremap <leader>s vip:!sort<cr>
" vnoremap <leader>s :!sort<cr>

" Tabs
nnoremap <leader>( :tabprev<cr>
nnoremap <leader>) :tabnext<cr>

" Copying text to the system clipboard.
"
" For some reason Vim no longer wants to talk to the OS X pasteboard through "*.
" Computers are bullshit.
function! g:FuckingCopyTheTextPlease()
  normal! gv
  silent '<,'>w !pbcopy
endfunction
noremap <leader>p :silent! set paste<CR>"*p:set nopaste<CR>
noremap <leader>p :r!pbpaste<cr>
vnoremap <leader>y :<c-u>call g:FuckingCopyTheTextPlease()<cr>

" I constantly hit "u" in visual mode when I mean to "y". Use "gu" for those rare occasions.
" From https://github.com/henrik/dotfiles/blob/master/vim/config/mappings.vim
vnoremap u <nop>
vnoremap gu u

" Highlight Group(s)
nnoremap <F8> :echo "hi<" . synIDattr(synID(line("."),col("."),1),"name") . '> trans<'
            \ . synIDattr(synID(line("."),col("."),0),"name") . "> lo<"
            \ . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"<CR>

" Clean trailing whitespace
nnoremap <leader>w mz:%s/\s\+$//<cr>:let @/=''<cr>`z

" Send visual selection to gist.github.com as a private, filetyped Gist
" Requires the gist command line too (brew install gist)
" vnoremap <leader>G :w !gist -p -t %:e \| pbcopy<cr>
" vnoremap <leader>UG :w !gist -p \| pbcopy<cr>

" Insert the directory of the current buffer in command line mode
cnoremap <expr> %% getcmdtype() == ':' ? expand('%:h').'/' : '%%'

" Panic Button
nnoremap <f9> mzggg?G`z

" Emacs bindings in command line mode
cnoremap <c-a> <home>
cnoremap <c-e> <end>

" Diffoff
nnoremap <leader>D :diffoff!<cr>

" Formatting, TextMate-style
nnoremap Q gqip
vnoremap Q gq

" Easier linewise reselection
nnoremap <leader>V V`]

" Keep the cursor in place while joining lines
nnoremap J mzJ`z

" Split line (sister to [J]oin lines)
" The normal use of S is covered by cc, so don't worry about shadowing it.
nnoremap S i<cr><esc>^mwgk:silent! s/\v +$//<cr>:noh<cr>`w

" HTML tag closing
inoremap <C-_> <Space><BS><Esc>:call InsertCloseTag()<cr>a

" Source
vnoremap <leader>S y:execute @@<cr>:echo 'Sourced selection.'<cr>
nnoremap <leader>S ^vg_y:execute @@<cr>:echo 'Sourced line.'<cr>

" Reselect the visuals when indenting. Borks slightly with undoing, but
" you'll get used to it.
vnoremap < <gv
vnoremap > >gv

" Easier escaping!
inoremap jj <ESC>
inoremap jk <ESC>

" Sudo to write
cnoremap w!! w !sudo tee % >/dev/null

" Typos
command! -bang E e<bang>
command! -bang Q q<bang>
command! -bang W w<bang>
command! -bang QA qa<bang>
command! -bang Qa qa<bang>
command! -bang Wa wa<bang>
command! -bang WA wa<bang>
command! -bang Wq wq<bang>
command! -bang WQ wq<bang>

" I suck at typing.
nnoremap <localleader>= ==
vnoremap - =

" Toggle paste
" For some reason pastetoggle doesn't redraw the screen (thus the status bar
" doesn't change) while :set paste! does, so I use that instead.
" set pastetoggle=<F6>
nnoremap <silent> <F6> :set paste!<cr>

" Toggle [i]nvisible characters
nnoremap <leader>i :set list!<cr>

" Unfuck my screen
nnoremap U :syntax sync fromstart<cr>:redraw!<cr>

" Insert Mode Completion {{{

inoremap <c-f> <c-x><c-f>
inoremap <c-]> <c-x><c-]>


" }}}
" Quick split {{{

nmap <c-z> :sp<cr>
nmap <c-s> :vsp<cr>
nmap <c-q> :q<cr>

" }}}
" Better for the hands {{{

nmap zh gT
nmap zl gt
exec "nmap zn :tabe "
exec "nmap zH :tab he "

" loclist mappings.
nmap ch :lpe<CR>
nmap cj :ll<CR>
nmap ck :lw<CR>
nmap cl :lne<CR>

" Same, but for quickfix
nmap cqh :cp<CR>
nmap cqj :cc<CR>
nmap cqk :cw<CR>
nmap cql :cn<CR>

" Diffing
nmap dn ]c
nmap dN [c

" }}}
" Quick editing {{{

nmap <leader>ee :e %%
nmap <leader>es :sp %%
nmap <leader>ev :vsp %%
nmap <leader>et :tabe %%

" }}}

" }}}
" Searching and movement {{{

" Use sane regexes.
nnoremap / /\v
vnoremap / /\v
" Because slash is shift-bound on Swedish keyboards. - is the US key for /
nmap - /

set ignorecase
set smartcase
set incsearch
set showmatch
set hlsearch
set gdefault

set scrolloff=3
set sidescroll=1
set sidescrolloff=10

set virtualedit+=block

noremap <silent> <leader><space> :noh<cr>:call clearmatches()<cr>

runtime macros/matchit.vim
map <tab> %
" unmap [%
" unmap ]%

" Made D behave
nnoremap D d$


" Don't move on *
nnoremap * *<c-o>

" Use enter to do c-] but open it in a new split.
nnoremap <cr> <c-]>zvzz
nnoremap <c-cr> <c-w>v<c-]>zvzz

" Keep search matches in the middle of the window.
nnoremap n nzzzv
nnoremap N Nzzzv

" Same when jumping around
nnoremap g; g;zz
nnoremap g, g,zz
nnoremap <c-o> <c-o>zz

" Easier to type, and I never use the default behavior.
noremap H ^
noremap L $
vnoremap L g_

" Heresy
inoremap <c-a> <esc>I
inoremap <c-e> <esc>A

" gi already moves to "last place you exited insert mode", so we'll map gI to
" something similar: move to last change
nnoremap gI `.

" Directional Keys {{{

" It's 2012.
noremap j gj
noremap k gk
noremap gj j
noremap gk k

" Easy buffer navigation
noremap <C-h> <C-w>h
noremap <C-j> <C-w>j
noremap <C-k> <C-w>k
noremap <C-l> <C-w>l

noremap <leader>v <C-w>v

" }}}
" Visual Mode */# from Scrooloose {{{

function! s:VSetSearch()
  let temp = @@
  norm! gvy
  let @/ = '\V' . substitute(escape(@@, '\'), '\n', '\\n', 'g')
  let @@ = temp
endfunction

vnoremap * :<C-u>call <SID>VSetSearch()<CR>//<CR><c-o>
vnoremap # :<C-u>call <SID>VSetSearch()<CR>??<CR><c-o>

" }}}
" List navigation {{{

nnoremap <left>  :cprev<cr>zvzz
nnoremap <right> :cnext<cr>zvzz
nnoremap <up>  :lprev<cr>zvzz
nnoremap <down>  :lnext<cr>zvzz

" }}}

" }}}
" Folding {{{

set foldlevelstart=0

" Space to toggle folds.
nnoremap <Space> za
nnoremap <C-Space> zM
nnoremap <S-Space> zO

" Make zO recursively open whatever top level fold we're in, no matter where the
" cursor happens to be.
nnoremap zO zCzO

" This fucker will destroy all your foldmarkers. That's a real bummer if you're
" in C, Javascript or CSS where your markers are actual parts of the code. I've
" accidentally hit zE while going for zR so many times that this is actually
" warranted.
nmap zE :echo "Don't do that."<cr>

nmap <leader>fm :set foldmethod=marker<cr>
nmap <leader>fi :set foldmethod=indent<cr>
nmap <leader>fx :set foldmethod=expr<cr>
nmap <leader>fp :set foldmethod=expr foldexpr=ParagraphFold\(v:lnum\)<cr>

function! ParagraphFold(lnum)
  " See examples at :he fold-expr
  if getline(a:lnum) =~ '^\s*$' && getline(a:lnum+1) =~ '\S'
    return '<1'
  else
    return 1
  endif
endfunction

function! FoldWithLines()
  " Folding function that puts the line counter indication at &tw if &tw is set
  " or at 79 if not.
  " Makes for readable fold information even if you only have one window open in
  " a wide instance of vim.

  let nucolwidth = &fdc + &number * &numberwidth
  let winwd = winwidth(0) - nucolwidth - 5
  let foldlinecount = foldclosedend(v:foldstart) - foldclosed(v:foldstart) + 1
  let foldinfo = " " . string(foldlinecount) . " lines "

  let linedata = ""

  " If there is a filetype specific foldtext method defined, use that to get the
  " foldtext data line.
  for ft in split(&ft, '\.')
    if exists('*FoldText_' . ft)
      let linedata = FoldText_{ft}(v:foldstart)
      break
    endif
  endfor

  if linedata == ""
    let linedata = getline(v:foldstart)
  endif

  let line = strpart(linedata, 0 , winwd - len(foldinfo)) . " "

  if &tw
    let base = &tw
  else
    let base = 79
  endif

  " Handle lines that are too long! Cut em down!
  if len(line) + len(foldinfo) > base
    let max = base - len(foldinfo) - 5
    let line = line[:max] . '... '
  endif

  let fillcharcount = base - len(line) - len(foldinfo)
  return line . repeat("-", fillcharcount) . foldinfo
endfunction

set foldtext=FoldWithLines()

" }}}
" Filetype-specific {{{

" CSS and LessCSS {{{

augroup ft_css
  au!

  au BufNewFile,BufRead *.less setlocal filetype=less

  au Filetype less,css setlocal foldmethod=marker
  au Filetype less,css setlocal foldmarker={,}
  au Filetype less,css setlocal omnifunc=csscomplete#CompleteCSS
  au Filetype less,css setlocal iskeyword+=-

  " Use <leader>S to sort properties.  Turns this:
  "
  "   p {
  "     width: 200px;
  "     height: 100px;
  "     background: red;
  "
  "     ...
  "   }
  "
  " into this:

  "   p {
  "     background: red;
  "     height: 100px;
  "     width: 200px;
  "
  "     ...
  "   }
  au BufNewFile,BufRead *.less,*.css nnoremap <buffer> <localleader>S ?{<CR>jV/\v^\s*\}?$<CR>k:sort<CR>:noh<CR>

  " Make {<cr> insert a pair of brackets in such a way that the cursor is correctly
  " positioned inside of them AND the following code doesn't get unfolded.
  au BufNewFile,BufRead *.less,*.css inoremap <buffer> {<cr> {}<left><cr><space><space><space><space>.<cr><esc>kA<bs>
augroup END

" }}}
" Django {{{

augroup ft_django
  au!

  au BufNewFile,BufRead urls.py       setlocal nowrap
  au BufNewFile,BufRead urls.py       normal! zR
  au BufNewFile,BufRead dashboard.py    normal! zR
  au BufNewFile,BufRead local_settings.py normal! zR
augroup END

" }}}
" HTML, Django, Jinja, Dram {{{

" The base set, just add li and p
let g:html_indent_tags = 'a\|abbr\|acronym\|address\|b\|bdo\|big\|blockquote\|button\|caption\|center\|cite\|code\|colgroup\|del\|dfn\|dir\|div\|dl\|em\|fieldset\|font\|form\|frameset\|h1\|h2\|h3\|h4\|h5\|h6\|i\|iframe\|ins\|kbd\|label\|legend\|map\|menu\|noframes\|noscript\|object\|ol\|optgroup\|q\|s\|samp\|script\|select\|small\|span\|strong\|style\|sub\|sup\|table\|textarea\|title\|tt\|u\|ul\|var\|body\|head\|html\|tbody\|th\|td\|tr\|tfoot\|thead\|li\|p'

augroup ft_html
  au!

  au FileType html,htmldjango setlocal foldmethod=indent
augroup END

" }}}
" Javascript {{{

augroup ft_javascript
  au!

  au FileType javascript setlocal foldmethod=marker
  au FileType javascript setlocal foldmarker={,}
augroup END

" }}}
" JSON {{{

augroup json_autocmd
  au!
  au BufEnter *.json setlocal shiftwidth=4 softtabstop=4 expandtab textwidth=0
  au BufEnter *.json setlocal foldmethod=marker foldmarker={,}
augroup END

" }}}
" Markdown {{{

augroup ft_markdown
  au!

  au BufNewFile,BufRead *.m*down setlocal filetype=markdown foldlevel=1

  " Use <localleader>1/2/3 to add headings.
  au Filetype markdown nnoremap <buffer> <localleader>1 yypVr=:redraw<cr>
  au Filetype markdown nnoremap <buffer> <localleader>2 yypVr-:redraw<cr>
  au Filetype markdown nnoremap <buffer> <localleader>3 mzI###<space>`zllll <ESC>
augroup END

" }}}
" Nginx {{{

augroup ft_nginx
  au!

  au BufRead,BufNewFile *nginx/*.conf set ft=nginx

  au FileType nginx set foldmethod=marker foldmarker={,} expandtab
  au FileType nginx set shiftwidth=4 softtabstop=4
  au FileType nginx set omnifunc=syntaxcomplete#Complete commentstring=#%s
augroup END

" }}}
" Python {{{

" Just add one shiftwidth when indenting python
let g:pyindent_open_paren = 4

function! PySwitchDef(l1, l2)
  let q = "[\"']"
  let obj = '\(\w\+\)\>=\(.\+\)$'
  let dict = q.'\(\w\+\)' .q.':\s\+\(.\+\)$'

  let lines = getline(a:l1, a:l2)
  let processed = []

  for line in lines
    let changed = 0

    if match(line, obj) != -1
      let line = substitute(line, obj, '"\1": \2', '')
      let changed = 1
    elseif match(line, dict) != -1
      let line = substitute(line, dict, '\1=\2', '')
      let changed = 1
    endif

    if changed && match(line, ',$') == -1
      let line = line . ','
    endif

    let processed = add(processed, line)
  endfor

  call setline(a:l1, processed)
endfunction

command! -range -nargs=0 PySwitchDef :call PySwitchDef(<line1>, <line2>)
nmap <silent> <leader>d :PySwitchDef<cr>
vmap <silent> <leader>d :PySwitchDef<cr>gv

augroup ft_python
  au!

  au FileType python setlocal define=^\s*\\(def\\\\|class\\)
  au FileType man nnoremap <buffer> <cr> :q<cr>
  au Filetype python syn keyword Special self
  au Filetype python setlocal sts=4 sw=4
  au FileType python setlocal foldmethod=expr foldexpr=PythonFold\(v:lnum\)

  " Jesus tapdancing Christ, built-in Python syntax, you couldn't let me
  " override this in a normal way, could you?
  au FileType python if exists("python_space_error_highlight") | unlet python_space_error_highlight | endif
augroup END

augroup pythonfold_reloader
  au!
  au BufWritePost pythonfold.vim so %
augroup END

" }}}
" Vim {{{

function! HelpExpand()
  exec "help" expand('<cword>')
endfunction

augroup ft_help
  au!

  au FileType help setlocal textwidth=78
  au FileType help nnoremap <buffer> <cr> <C-]>
  au FileType help nnoremap <buffer> q :q<cr>
  au FileType help nnoremap <buffer> <c-c> :q<cr>
  au BufWinEnter *.txt if &ft == 'help' | wincmd L | endif
augroup END

augroup ft_quickfix
  au!

  " Disable any mapping of enter in quickfix buffers
  au Filetype qf nnoremap <cr> <cr>
  au Filetype qf setlocal colorcolumn=0 nolist nowrap tw=0
augroup END

augroup ft_vim
  au!

  " If on real vimrc, source it upon save
  au BufWritePost *vimrc* let fn = expand("<afile>:p") | if fn !~ '://' | source `=fn` | endif
  au FileType vim setlocal foldmethod=marker
  au FileType vim nnoremap <buffer> <silent> <bs> :call HelpExpand()<cr>
augroup END

" }}}
" XML {{{

" Try to properly format an XML file. Will break if there are syntax errors
" in the file.
" Not filetype specific, since it is useful in HTML and others as well.
nmap <Leader>ix :%s/>/>\r/<cr>:%s/</\r</<cr>gg=G:g/^$/d<cr>

" }}}

" }}}
" Plugin settings {{{

" Commentary {{{

" Backslash is horrible on swedish layouts. ö is not.
nmap ö \\\
vmap ö \\\

" }}}
" Ctrl-P {{{

let g:ctrlp_dont_split = 'NERD_tree_2'
let g:ctrlp_jump_to_buffer = 0
let g:ctrlp_map = '<leader>q'
let g:ctrlp_working_path_mode = 0
let g:ctrlp_match_window_reversed = 1
let g:ctrlp_split_window = 0
let g:ctrlp_max_height = 20
let g:ctrlp_extensions = ['tag']
let g:ctrlp_custom_ignore = '\.git$\|\.hg$\|\.svn$\|eggs\?$'

let g:ctrlp_prompt_mappings = {
\ 'PrtSelectMove("j")':   ['<c-j>', '<down>', '<s-tab>'],
\ 'PrtSelectMove("k")':   ['<c-k>', '<up>', '<tab>'],
\ 'PrtHistory(-1)':     ['<c-n>'],
\ 'PrtHistory(1)':    ['<c-p>'],
\ 'ToggleFocus()':    ['<c-tab>'],
\ }

nnoremap <leader>. :CtrlPTag<cr>
nnoremap <A-d> :CtrlP<cr>
nnoremap <Leader>q :CtrlP<cr>
nnoremap <Leader>a :CtrlPBuffer<cr>
nnoremap <Leader>z :CtrlPTag<cr>
nnoremap <Leader>Q :CtrlPReload<cr>

" }}}
" Fugitive {{{

fun! s:gm(short, cmd, ...)  " git_map
  let silent = a:cmd =~ '\w$' ? '<silent>' : ''
  let cr = a:cmd =~ '\w$' ? '<cr>' : ''
  let extra = a:0 ? a:1 : ''
  exec "nmap" silent a:short ":" . a:cmd . cr . extra
endfunction

call s:gm('gi',  'Git ')
call s:gm('ge',  'Gedit')
call s:gm('gb',  'Gblame')
call s:gm('gc',  'Gcommit')
call s:gm('gdd', 'Gdiff ')
call s:gm('gdc', 'Gdiff')
call s:gm('gdh', 'Gdiff HEAD')

" Check previous revisions of current file; git log
call s:gm('gle', 'Extradite')
call s:gm('gll', 'Glog')
call s:gm('glo', 'Glog ')
call s:gm('go',  'Gcheckout ')
call s:gm('gpp', 'Git push origin ')
call s:gm('guu', 'Git pull --no-edit origin')
call s:gm('gre', 'Gread ')
call s:gm('grr', 'Gremove ')

call s:gm('gs',  'Gstatus', '<c-n>')
call s:gm('gw',  'Gwrite')
call s:gm('ga',  'Gwrite')
call s:gm('gm',  'Gmove ')

" }}}
" NERD Tree {{{

noremap  <F2> :NERDTreeToggle<cr>
inoremap <F2> <esc>:NERDTreeToggle<cr>

augroup ps_nerdtree
  au!

  au Filetype nerdtree setlocal nolist
  " au Filetype nerdtree nnoremap <buffer> K :q<cr>
augroup END

let NERDTreeHighlightCursorline = 1
let NERDTreeIgnore = ['\~$', '.*\.pyc$', 'pip-log\.txt$', 'whoosh_index',
          \ 'xapian_index', '.*.pid', 'monitor.py', '.*-fixtures-.*.json',
          \ '.*\.o$', 'db.db', 'tags.bak']

let NERDTreeMinimalUI = 1
let NERDTreeDirArrows = 1
let NERDChristmasTree = 1
let NERDTreeChDirMode = 2
let NERDTreeMapJumpFirstChild = 'gK'

" }}}
" Powerline {{{

" let g:Powerline_symbols = 'fancy'
let g:Powerline_cache_enabled = 1
let g:Powerline_colorscheme = 'badwolf'

" }}}
" Reinhardt {{{

let g:reinhardt_mapkey = "r"

" }}}
" Snakecharmer {{{

let g:snakecharm_sort_imports = 1

" }}}
" Sparkup {{{

" let g:sparkupExecuteMapping = '<C-E>'
let g:sparkupNextMapping = '<F13>'

"}}}
" Syntastic {{{

let g:syntastic_enable_signs = 1
let g:syntastic_check_on_open = 0
let g:syntastic_disabled_filetypes = ['html', 'rst', 'css']
let g:syntastic_stl_format = '[%E{%e Errors}%B{, }%W{%w Warnings}]'
let g:syntastic_javascript_jslint_conf = "--maxerr 1000 --white --undef --nomen --regexp --plusplus --bitwise --newcap --sloppy --vars --continue"
let g:syntastic_python_checker = 'flake8'
let g:syntastic_python_checker_args = '--ignore=E501'  " Ignore line too long

" }}}
" SQL {{{

" The retard that set C-C as default for SQL completion should get his face
" caved in.
let g:ftplugin_sql_omni_key = '<F13>'

" }}}
" surround {{{

" While I love surround.vim, the s/S confusion in visual mode does not
" really tickle my fancy. To make up for this, these mappings happened.
" vmap " S"

vmap ' S'
vmap ( S)
vmap [ S]
vmap { S}

" }}}
" unimpaired {{{

nmap <A-j> ]e
nmap <A-k> [e
vmap <A-j> ]egv
vmap <A-k> [egv

vmap <C-j> ]egv
vmap <C-k> [egv

" }}}
" vimwiki {{{

let g:vimwiki_list = [{'path': '~/.local/share/vimwiki/main/', 'path_html': '~/.local/share/vimwiki/html'}, {'path': '~/etc/vim/bundle/reinhardt/vimwiki', 'path_html': '~/.local/share/vimwiki/html'}]
let g:vimwiki_folding = 1

" }}}
" XPTemplate {{{

" let g:xptemplate_snippet_folders=['$HOME/.vim/xpt']
let g:xptemplate_brace_complete = 0  " Other plugins does this way better
let g:xptemplate_key = '<Tab>'  " Main snippet key
let g:xptemplate_key_pum_only = '<C-F>'  " Popup key
let g:xptemplate_nav_cancel = '<C-D>'  " Cancel key
let g:xptemplate_nav_next = '<C-J>'  " Next key
let g:xptemplate_goback = '<C-K>'  " Prev key
let g:xptemplate_to_right = '<C-L>'  " Exit key
let g:xptemplate_pum_tab_nav = 1  " Tab navigation in popup menu

" Easy reload
nmap <leader>r :XPTreload<CR>

" }}}

" }}}
" Text objects {{{

" Shortcut for [] {{{

onoremap ir i[
onoremap ar a[
vnoremap ir i[
vnoremap ar a[

" }}}
" Next and Last {{{
"
" Motion for "next/last object".  "Last" here means "previous", not "final".
" Unfortunately the "p" motion was already taken for paragraphs.
"
" Next acts on the next object of the given type in the current line, last acts
" on the previous object of the given type in the current line.
"
" Currently only works for (, [, {, b, r, B, ', and ".
"
" Some examples (C marks cursor positions, V means visually selected):
"
" din'  -> delete in next single quotes        foo = bar('spam')
"                            C
"                            foo = bar('')
"                                C
"
" canb  -> change around next parens           foo = bar('spam')
"                            C
"                            foo = bar
"                                 C
"
" vil"  -> select inside last double quotes      print "hello ", name
"                                    C
"                            print "hello ", name
"                               VVVVVV

onoremap an :<c-u>call <SID>NextTextObject('a', 'f')<cr>
xnoremap an :<c-u>call <SID>NextTextObject('a', 'f')<cr>
onoremap in :<c-u>call <SID>NextTextObject('i', 'f')<cr>
xnoremap in :<c-u>call <SID>NextTextObject('i', 'f')<cr>

onoremap al :<c-u>call <SID>NextTextObject('a', 'F')<cr>
xnoremap al :<c-u>call <SID>NextTextObject('a', 'F')<cr>
onoremap il :<c-u>call <SID>NextTextObject('i', 'F')<cr>
xnoremap il :<c-u>call <SID>NextTextObject('i', 'F')<cr>

function! s:NextTextObject(motion, dir)
  let c = nr2char(getchar())

  if c ==# "b"
    let c = "("
  elseif c ==# "B"
    let c = "{"
  elseif c ==# "r"
    let c = "["
  endif

  exe "normal! ".a:dir.c."v".a:motion.c
endfunction

" }}}
" Numbers {{{

" Motion for numbers.  Great for CSS.  Lets you do things like this:
"
" margin-top: 200px; -> daN -> margin-top: px;
"        ^              ^
" TODO: Handle floats.

onoremap N :<c-u>call <SID>NumberTextObject(0)<cr>
xnoremap N :<c-u>call <SID>NumberTextObject(0)<cr>
onoremap aN :<c-u>call <SID>NumberTextObject(1)<cr>
xnoremap aN :<c-u>call <SID>NumberTextObject(1)<cr>
onoremap iN :<c-u>call <SID>NumberTextObject(1)<cr>
xnoremap iN :<c-u>call <SID>NumberTextObject(1)<cr>

function! s:NumberTextObject(whole)
  normal! v

  while getline('.')[col('.')] =~# '\v[0-9]'
    normal! l
  endwhile

  if a:whole
    normal! o

    while col('.') > 1 && getline('.')[col('.') - 2] =~# '\v[0-9]'
      normal! h
    endwhile
  endif
endfunction

" }}}

" }}}
" Mini-plugins {{{
" Stuff that should probably be broken out into plugins, but hasn't proved to be
" worth the time to do so just yet.

" Synstack {{{

" Show the stack of syntax hilighting classes affecting whatever is under the
" cursor.
function! SynStack()
  echo join(map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")'), " > ")
endfunc

nnoremap <F7> :call SynStack()<CR>

" }}}
" Diffwhite Toggle {{{

set diffopt-=iwhite
let g:diffwhitespaceon = 0
function! ToggleDiffWhitespace()
  if g:diffwhitespaceon
    set diffopt-=iwhite
    let g:diffwhitespaceon = 0
  else
    set diffopt+=iwhite
    let g:diffwhitespaceon = 1
  endif
  diffupdate
endfunc

nnoremap <leader>dw :call ToggleDiffWhitespace()<CR>

" }}}
" Error Toggles {{{

command! ErrorsToggle call ErrorsToggle()
function! ErrorsToggle() " {{{
  if exists("w:is_error_window")
  unlet w:is_error_window
  exec "q"
  else
  exec "Errors"
  lopen
  let w:is_error_window = 1
  endif
endfunction " }}}

command! -bang -nargs=? QFixToggle call QFixToggle(<bang>0)
function! QFixToggle(forced) " {{{
  if exists("g:qfix_win") && a:forced == 0
  cclose
  unlet g:qfix_win
  else
  copen 10
  let g:qfix_win = bufnr("$")
  endif
endfunction " }}}

nmap <silent> <f3> :ErrorsToggle<cr>
nmap <silent> <f4> :QFixToggle<cr>

" }}}
" Ack motions {{{

" Motions to Ack for things.  Works with pretty much everything, including:
"
"   w, W, e, E, b, B, t*, f*, i*, a*, and custom text objects
"
" Awesome.
"
" Note: If the text covered by a motion contains a newline it won't work.  Ack
" searches line-by-line.

nnoremap <silent> <leader>A :set opfunc=<SID>AckMotion<CR>g@
xnoremap <silent> <leader>A :<C-U>call <SID>AckMotion(visualmode())<CR>

" nnoremap <bs> :Ack! '\b<c-r><c-w>\b'<cr>
" xnoremap <silent> <bs> :<C-U>call <SID>AckMotion(visualmode())<CR>

function! s:CopyMotionForType(type)
  if a:type ==# 'v'
    silent execute "normal! `<" . a:type . "`>y"
  elseif a:type ==# 'char'
    silent execute "normal! `[v`]y"
  endif
endfunction

function! s:AckMotion(type) abort
  let reg_save = @@

  call s:CopyMotionForType(a:type)

  execute "normal! :Ack! --literal " . shellescape(@@) . "\<cr>"

  let @@ = reg_save
endfunction

" }}}
" Indent Guides {{{

let g:indentguides_state = 0
function! IndentGuides() " {{{
  if g:indentguides_state
    let g:indentguides_state = 0
    2match None
  else
    let g:indentguides_state = 1
    execute '2match IndentGuides /\%(\_^\s*\)\@<=\%(\%'.(0*&sw+1).'v\|\%'.(1*&sw+1).'v\|\%'.(2*&sw+1).'v\|\%'.(3*&sw+1).'v\|\%'.(4*&sw+1).'v\|\%'.(5*&sw+1).'v\|\%'.(6*&sw+1).'v\|\%'.(7*&sw+1).'v\)\s/'
  endif
endfunction " }}}
hi def IndentGuides guibg=#303030
nnoremap <leader>I :call IndentGuides()<cr>

" }}}
" Block Colors {{{

let g:blockcolor_state = 0
function! BlockColor() " {{{
  if g:blockcolor_state
    let g:blockcolor_state = 0
    call matchdelete(77881)
    call matchdelete(77882)
    call matchdelete(77883)
    call matchdelete(77884)
    call matchdelete(77885)
    call matchdelete(77886)
  else
    let g:blockcolor_state = 1
    " TODO: Make a loop that respects &sw
    call matchadd("BlockColor1", '^ \{4}.*', 1, 77881)
    call matchadd("BlockColor2", '^ \{8}.*', 2, 77882)
    call matchadd("BlockColor3", '^ \{12}.*', 3, 77883)
    call matchadd("BlockColor4", '^ \{16}.*', 4, 77884)
    call matchadd("BlockColor5", '^ \{20}.*', 5, 77885)
    call matchadd("BlockColor6", '^ \{24}.*', 6, 77886)
  endif
endfunction " }}}
" Default highlights {{{
hi def BlockColor1 guibg=#222222 ctermbg=234
hi def BlockColor2 guibg=#2a2a2a ctermbg=235
hi def BlockColor3 guibg=#353535 ctermbg=236
hi def BlockColor4 guibg=#3d3d3d ctermbg=237
hi def BlockColor5 guibg=#444444 ctermbg=238
hi def BlockColor6 guibg=#4a4a4a ctermbg=239
" }}}
nnoremap <leader>B :call BlockColor()<cr>

" }}}
" Highlight Word {{{
"
" This mini-plugin provides a few mappings for highlighting words temporarily.
"
" Sometimes you're looking at a hairy piece of code and would like a certain
" word or two to stand out temporarily.  You can search for it, but that only
" gives you one color of highlighting.  Now you can use <leader>N where N is
" a number from 1-6 to highlight the current word in a specific color.

function! HiInterestingWord(n) " {{{
  " Save our location.
  normal! mz

  " Yank the current word into the z register.
  normal! "zyiw

  " Calculate an arbitrary match ID.  Hopefully nothing else is using it.
  let mid = 86750 + a:n

  " Clear existing matches, but don't worry if they don't exist.
  silent! call matchdelete(mid)

  " Construct a literal pattern that has to match at boundaries.
  let pat = '\V\<' . escape(@z, '\') . '\>'

  " Actually match the words.
  call matchadd("InterestingWord" . a:n, pat, 1, mid)

  " Move back to our original location.
  normal! `z
endfunction " }}}

" Mappings {{{

nnoremap <silent> <leader>1 :call HiInterestingWord(1)<cr>
nnoremap <silent> <leader>2 :call HiInterestingWord(2)<cr>
nnoremap <silent> <leader>3 :call HiInterestingWord(3)<cr>
nnoremap <silent> <leader>4 :call HiInterestingWord(4)<cr>
nnoremap <silent> <leader>5 :call HiInterestingWord(5)<cr>
nnoremap <silent> <leader>6 :call HiInterestingWord(6)<cr>

" }}}
" Default Highlights {{{

hi def InterestingWord1 guifg=#000000 ctermfg=16 guibg=#ffa724 ctermbg=214
hi def InterestingWord2 guifg=#000000 ctermfg=16 guibg=#aeee00 ctermbg=154
hi def InterestingWord3 guifg=#000000 ctermfg=16 guibg=#8cffba ctermbg=121
hi def InterestingWord4 guifg=#000000 ctermfg=16 guibg=#b88853 ctermbg=137
hi def InterestingWord5 guifg=#000000 ctermfg=16 guibg=#ff9eb8 ctermbg=211
hi def InterestingWord6 guifg=#000000 ctermfg=16 guibg=#ff2c4b ctermbg=195

" }}}

" }}}
" Font resizer {{{

function! GuiFont(size)
  let spl = split(a:size == 0 ? g:guifont_save : &guifont, ' ')
  let size = spl[-1]
  exec "set guifont=" . join(spl[:-2], '\ ') . '\ ' . (size + a:size)

  wincmd =
  redraw!
endfunction

let g:guifont_save = &guifont
nmap <silent> <c-up> :<C-U>call GuiFont(1)<cr>
nmap <silent> <c-down> :<C-U>call GuiFont(-1)<cr>
nmap <silent> <c-left> :<C-U>call GuiFont(0)<cr>

" }}}

" }}}
" Environments (GUI/Console) {{{

if has('gui_running')
  " Remove all the UI cruft
  set guioptions=cagit  " Disable graphical elements
  set guifont=Inconsolata\ 13

  " Different cursors for different modes.
  set guicursor=n-c:block-Cursor-blinkon0
  set guicursor+=v:block-vCursor-blinkon0
  set guicursor+=i-ci:ver20-iCursor
else
  " Mouse support
  set mouse=a
endif

" }}}
" User specific settings {{{

let userfile = globpath(&runtimepath, 'local.vim')
if filereadable(userfile)
  execute 'source ' . userfile
endif

" }}}
