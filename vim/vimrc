" vimrc by Lowe Thiderman (daethorian@ninjaloot.se)
" Released under the WTFPL (http://sam.zoy.org/wtfpl/).

" Once upon a time based on MetaCosms vimrc (http://www.vi-improved.org/vimrc.php)

" Basics {
    set nocompatible        " disable horrible vi compatability mode!
    set background=dark " we are using a dark background
    set hidden
    syntax enable
" }
" General {
    nohls " When starting vim, disable first hls
    set history=100 " How many lines of history to remember
    set iskeyword+=_,$,@,%,# " none of these should be word dividers, so make them not be
    set nostartofline " leave my cursor where it was
    set backspace=indent,eol,start
    set gdefault " always replace everything when substituting
    set magic " use magic regular expressions
    set autoread " reload files that has changed externally
    set ttyfast " Oh, right, this isn't the 70s
" }
" Pathogen {
    call pathogen#runtime_append_all_bundles()
" }
" Filetypes {
    au Filetype python setlocal foldmethod=indent expandtab ft=python.django
    au Filetype python setlocal makeprg=pep8\ -r\ %
    au Filetype python syn keyword Special self
    au Filetype html,htmldjango set foldmethod=indent expandtab ft=htmldjango.html

    " TODO: omg full paths :////
    au Filetype javascript setlocal makeprg=cat\ %\ \\\|\ /usr/bin/js\ /home/daethorian/config/vim/jslint/mylintrun.js\ %
    au Filetype javascript setlocal errorformat=%f:%l:%c:%m
    au Filetype javascript syn keyword Special $

    au FileType help nnoremap <buffer> <Enter> <C-]>

    augroup filetypedetect
        au BufNewFile,BufRead *.notes setf notes
    augroup END

    au ColorScheme * source ~/.vim/plugin/bold.vim
" }
" Files/Backups (XDG style) {
    set viminfo='100,<50,s10,h,!,n~/.cache/vim/viminfo
    set backup " make backup file
    set backupdir=~/.cache/vim/backup " where to put backup file
    set directory=~/.cache/vim/tmp " directory is the directory for temp file

    " Autocreate the needed directories if they don't exist
    if isdirectory(&directory) == 0
        silent! !mkdir -p "$HOME/.cache/vim/backup"
        silent! !mkdir -p "$HOME/.cache/vim/tmp"
    endif
" }
" Vim UI {
    set showcmd " show the command being typed
    set wildmenu " turn on wild menu
    " XXX: This one breaks in 7.3.138 for some reason
    set wildmode=list:longest " turn on wild menu in special format (long format)
    set wildignore=*.o,*.obj,*.bak,*.exe,*.pyc,*.swp,*.jpg,*.gif,*.png " ignore some formats
    set splitbelow " Split below
    set splitright " Split to the right
    "set ruler " Always show current positions along the bottom
    set cmdheight=1 " the command bar is 1 high
    set number " turn on line numbers
    set lazyredraw " do not redraw while running macros (much faster)
    set noerrorbells " don't make noise
    set laststatus=2 " always have the statusline

    if !exists("g:disable_status_syntax")
        let g:disable_status_syntax = 1 " Disable the syntax in statusline
    endif

    "set statusline=%<%f\:%l\,%v%{QuickfixCount()}\ %m\ %=%{fugitive#statusline()}\ %r%h%w%y\ %l\/%L\ %P
    set statusline=[%n]\                        " Buffer number
    set statusline+=%<%f                        " Filename
    set statusline+=%m\                         " Modified flag
    set statusline+=%1*%r%*                     " Readonly flag
    set statusline+=%w                          " Preview flag
    set statusline+=%{&ff!='unix'?'['.&ff.']':''} " display ff only if not unix

    set statusline+=%#Error# " display a warning if file encoding isnt utf-8
    set statusline+=%{(&fenc!='utf-8'&&&fenc!='')?'['.&fenc.']':''}%*
    set statusline+=%y                          " File type
    set statusline+=%#Error#                    " display a warning if &paste is set
    set statusline+=%{&paste?'[paste]':''}
    set statusline+=%{QuickfixCount()}      " display quicklist items
    set statusline+=%*

    set statusline+=%=                          " Left/right separator
    "set statusline+=%{StatuslineCurrentHighlight()}\ \  " current highlight
    set statusline+=%{fugitive#statusline()}\   " Fugitive status <3
    set statusline+=%c,%l/%L                    " Position column,line/total
    set statusline+=\ %P                        " Percentage through file


    " 256 colors to putty
    if &term =~ "xterm"
        set t_Co=256
        if has("terminfo")
            let &t_Sf=nr2char(27).'[3%p1%dm'
            let &t_Sb=nr2char(27).'[4%p1%dm'
        else
            let &t_Sf=nr2char(27).'[3%dm'
            let &t_Sb=nr2char(27).'[4%dm'
        endif
    endif
" }
" Visual Cues {
    if exists('+colorcolumn')
        set colorcolumn=+1 " Show a colored column one column from &tw
    endif
    set showmatch " show matching brackets
    set hlsearch " highlight searched phrases
    set incsearch " highlight as you type you search phrase
    set scrolloff=5 " Keep 5 lines (top/bottom) for scope
    set sidescrolloff=5 " Keep 5 lines at the side
    set novisualbell " don't blink
    set report=0 " always report number of lines changed
    set list " Show whitespace characters
    if has("multi_byte")
        set listchars=tab:»\ ,extends:›,precedes:‹,trail:·,nbsp:✂
    else
        set listchars=tab:>\ ,extends:>,precedes:<,trail:-,nbsp:%
    endif
    let &sbr = nr2char(8618).' ' " Show ↪ at the beginning of wrapped lines
" }
" Indent Related {
    set softtabstop=4 " unify
    set shiftwidth=4 " unify
    set tabstop=4 " real tabs should be 4, but they will show with set list on
    set copyindent " follow the conventions laid before us
    set expandtab " do not use tabs
    let g:pyindent_open_paren = &sw " Just add one shiftwidth when indenting python
    filetype plugin indent on " load filetype plugins and indent settings
" }
" Text Formatting/Layout {
    set formatoptions=tcrq " See Help (complex)
    set shiftround " when at 3 spaces, and I hit > ... go to 4, not 5
    set nowrap " do not wrap line
    set preserveindent " but above all -- follow the conventions laid before us
    set ignorecase " case insensitive by default
    set smartcase " if there are caps, go case-sensitive
    set completeopt=menu,longest,preview " improve the way autocomplete works
    set textwidth=79 " use the universal convention as a default
" }
" Spelling {
    if has('spell')
        autocmd filetype mail set spell spelllang=sv
        autocmd filetype *commit* set spell spelllang=en
    endif
" }
" Folding {
    set foldenable " Turn on folding
    set foldmarker={,} " Fold C style code
    set foldcolumn=1 " Give 1 column for fold markers
    set foldmethod=marker " Fold on the marker
    set foldlevel=0 " Open files with folds closed
    set foldopen=undo,search,jump,hor,tag,mark,quickfix " open folds when you do stuff

    set foldtext=FoldWithLines()
    function! FoldWithLines()
        let nucolwidth = &fdc + &number*&numberwidth
        let winwd = winwidth(0) - nucolwidth - 5
        let foldlinecount = foldclosedend(v:foldstart) - foldclosed(v:foldstart) + 1
        let fdnfo = " " . string(foldlinecount) . " lines "
        let line = strpart(getline(v:foldstart), 0 , winwd - len(fdnfo)) . " "
        if &tw
            let base = &tw
        else
            let base = 79
        endif
        let fillcharcount = base - len(line) - len(fdnfo)
        return line . repeat("-",fillcharcount) . fdnfo
    endfunction
" }
" Colorschemes {
    if &term == 'screen-256color' || &term == 'rxvt-unicode-256color'
        let g:force_lofi = 0
        colorscheme neverland
    else
        let g:force_lofi = 1
        colorscheme ninjaloot
    endif
" }
" Plugins {
    source $VIMRUNTIME/macros/matchit.vim
    let g:vimwiki_list = [{'path': '~/.local/share/vimwiki/main/', 'path_html': '~/.local/share/vimwiki/html'}]
" }
" XPT {
    " Set personal snippet folder location:
    let g:xptemplate_snippet_folders=['$HOME/.vim/xptemplate_personal_snippets']
    " Turn off automatic closing of quotes and braces:
    let g:xptemplate_brace_complete = 0
    " Snippet triggering key:
    let g:xptemplate_key = '<F1>'
    " Open the pop-up menu:
    let g:xptemplate_key_pum_only = '<F2>'
    " Clear current placeholder and jump to the next:
    imap <C-d> <Tab>
    let g:xptemplate_nav_cancel = '<C-d>'
    " Move to the next placeholder in a snippet:
    let g:xptemplate_nav_next = '<Tab>'
    " Go to the end of the current placeholder and in to insert mode:
    " <C-_> is actually CONTROL-/ on my keyboard.
    let g:xptemplate_to_right = '<C-_>'
    " Move cursor back to last placeholder:
    let g:xptemplate_goback = '<C-g>'
    " Use TAB/S-TAB to navigate through the pop-up menu:
    let g:xptemplate_pum_tab_nav = 1
    " Reload xptemplate snippets without quitting vim.
    nmap <A-F1> :XPTreload<CR>
" }
" Custom functions {
    function! WrapToggle() " {
        if &wrap == 0
            set nolist wrap linebreak
            echo 'Wrap enabled'
        else
            set list nowrap nolinebreak
            echo 'Wrap disabled'
        endif
    endfunction " }
    function! PasteToggle() " {
        if &paste == 0
            set paste
            echo 'Paste enabled'
        else
            set nopaste
            echo 'Paste disabled'
        endif
    endfunction " }
    function! SpellToggle() " {
        if &spelllang == "en"
            set spelllang=sv
            echo 'Spell set to swedish'
        else
            set spelllang=en
            echo 'Spell set to english'
        endif
    endfunction " }
    function! WhitespaceToggle() " {
        if &expandtab == 0
            set expandtab
            try
                silent :%s/\t/    /
            catch /E486:/
            endtry
            echo 'Whitespace set to space'
        else
            set noexpandtab
            try
                silent :%s/    /\t/
            catch /E486:/
            endtry
            echo 'Whitespace set to tabs'
        endif
    endfunction " }
    function! KillTrailingWhitespace(write_file) " {
        try
            :%s/\s\+$//
            echo 'Trailing whitespace eliminated'
        catch /E486:/
            echo 'No trailing whitespace'
        endtry

        if a:write_file == 1
            write
        endif
    endfunction " }
    function! SudoWrite() " {
        write !sudo tee %
    endfunction " }
    function! ColorschemeToggle() " {
        if g:colors_name == 'xoria'
            colorscheme wyvern
            hi Normal ctermbg=none
        else
            colorscheme xoria
        endif
    endfunction " }
    function! LoFiToggle() " {
        if g:force_lofi == 1
            let g:force_lofi = 0
            echo 'Lofi disabled'
        else
            let g:force_lofi = 1
            echo 'Lofi enabled'
            silent colorscheme ninjaloot
        endif
    endfunction " }
    function! JqueryTemplateEscape() " {
        " Escapes a jQuery template into a Django parsable format
        try
            silent :%s/{{/{% templatetag openvariable %}/
        catch /E486:/
        endtry

        try
            silent :%s/}}/{% templatetag closevariable %}/
        catch /E486:/
        endtry

        try
            silent :%s/\${ /${% templatetag openbrace %} /
        catch /E486:/
        endtry

        try
            silent :%s/ }/ {% templatetag closebrace %}/
        catch /E486:/
        endtry
        echo 'JSON escape done'
    endfunction " }
    function! QuickfixCount() " {
        let qflen = len(getqflist())
        let quick = qflen == 0 ? '' : '['.qflen.'cc]'

        let loclen = len(getloclist(0))
        let location = loclen == 0 ? '' : '['.loclen.'ll]'

        return quick . location
    endfunction " }
    "function! StatuslineCurrentHighlight() " {
        "if exists("g:disable_status_syntax") && g:disable_status_syntax
            "return ''
        "endif
        "let name = synIDattr(synID(line('.'),col('.'),1),'name')

        "if name == ''
            "return ''
        "else
            "let synId = synID(line('.'),col('.'),1)
            "let realSynId = synIDtrans(synId)
            "if synId == realSynId
                "let realsyn =  'Normal'
            "else
                "let realsyn =  synIDattr(realSynId, 'name')
            "endif
            "return '[' . name . '/' . realsyn . ']'
        "endif
    "endfunction " }
    function! StatusSyntaxToggle() " {
        if g:disable_status_syntax == 0
            let g:disable_status_syntax = 1
            echo 'Syntax shower disabled'
        else
            let g:disable_status_syntax = 0
            echo 'Syntax shower enabled'
        endif
    endfunction " }
    function! RelSwitch(source, target) " {
        let new = substitute(bufname("%"), a:source, a:target, 'g')
        if filereadable(new)
            edit `=new`
        else
            echo "Not a valid file: " . new
        endif
    endfunction " }
    command! -nargs=+ S :call RelSwitch(<f-args>)
" }
" Custom mappings {
    let mapleader = ","

    " Navigation {
        " Unmap them evil arrows
        noremap <Up> <NOP>
        noremap <Right> <NOP>
        noremap <Down> <NOP>
        noremap <Left> <NOP>
        inoremap <Up> <NOP>
        inoremap <Right> <NOP>
        inoremap <Down> <NOP>
        inoremap <Left> <NOP>

        " Map Ctrl-hjkl to be navigation when in insert mode.
        inoremap <C-h> <Left>
        inoremap <C-j> <Down>
        inoremap <C-k> <Up>
        inoremap <C-l> <Right>

        " Better searcher
        noremap <space> /

        " Reselect the visuals when indenting
        vnoremap < <gv
        vnoremap > >gv
    " }
    " Sourcing {
        nmap <Leader>v :source $MYVIMRC<cr>
        nmap <Leader>V :tabe $MYVIMRC<cr>
        nmap <Leader>t :NERDTreeToggle<cr><C-w>=
        nmap <Leader>x :!xclip %<cr>
        nmap <Leader>r :call ReloadAllSnippets()<cr>
    " }
    " Togglers {
        nmap <Leader>w :call WrapToggle()<cr>
        nmap <Leader>p :call PasteToggle()<cr>
        "nmap <Leader>l :call LoFiToggle()<cr>
        nmap <Leader>l :call SpellToggle()<cr>
        nmap <Leader>C :call ColorschemeToggle()<cr>
        nmap <Leader>y :call StatusSyntaxToggle()<cr>
        nmap <Leader>s mt:call WhitespaceToggle()<cr>`t
        nmap <Leader>S mt:call KillTrailingWhitespace(0)<cr>`t
        nnoremap <silent> <C-l> :nohl<CR><C-l>
    " }
    " Fugitive <3 {
        nmap ge :Git 
        nmap gb :Gblame<cr>
        nmap gc :Gcommit<cr>
        nmap gdd :Gdiff 
        nmap gdh :Gdiff HEAD<cr>
        nmap gl :Glog<cr>
        nmap go :Git checkout 
        nmap gpp :Git push 
        nmap gre :Gread 
        nmap grr :Gremove
        nmap gs :Gstatus<cr>
        nmap gw :Gwrite<cr>
        nmap gm :Gmove 
    " }
    " Misc. {
        "com! W call SudoWrite()
        " Show syntax groups beneath cursor
        " TODO: Make function
        nmap <Leader>g  :echo "hi<" . synIDattr(synID(line("."),col("."),1),"name") . '> trans<' . synIDattr(synID(line("."),col("."),0),"name") . "> lo<" . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"<CR>
        nmap gpb o{<cr>}<esc>k

        " Search for all single/double-quoted strings
        nmap <Leader>hs /\('.\{-}'\\|".\{-}"\)<cr>
        nmap <Leader>m :make<cr>
        nmap <Leader>f gggqG
        nmap <Leader>a ,lj
    " }
    " Folding {
        nmap <Leader>fm :set foldmethod=marker<cr>
        nmap <Leader>fi :set foldmethod=indent<cr>
    " }
    " CSS {
        nmap <Leader>b A {<cr>}<esc>k^
    " }
    " XML {
        nmap <Leader>ix :%s/>/>\r/<cr>:%s/</\r</<cr>gg=G:g/^$/d<cr>
    " }
    " Django {
        nmap <Leader>dj :call JqueryTemplateEscape()<cr>
    " }
    " Better tabs for the hands {
        nmap zh gT
        nmap zl gt
        nmap zn :tabe 
        nmap zH :tab he 
    " }
    " I hate these {
        nmap K k
        vmap K k
        nmap S S<esc>
        noremap Q gq
        nnoremap Y y$
        nnoremap ; :
    " }
" }

" For now, set this down here
source /home/daethorian/.vim/after/plugin/statusline.vim

" vim: set et:sw=4:fmr=marker:fdm={,}
