#+TITLE: init file for Emacs
#+AUTHOR: Lowe Thiderman
#+EMAIL: lowe.thiderman@gmail.com
#+CREDIT: Howard Abrams <howard.abrams@gmail.com> (github.com/howardabrams/dot-files)

This is my emacs setup, and it's a constant work in progress. The current
setup is like this, as an [[https://orgmode.org][org-mode]] plain text file that compiles down to an
elisp file that is executed upon startup. org-mode was chosen since it helps
organize the file, gives nice folding, and sets up for writing inline
documentation in a style similar to literate programming.

* Common Lisp

  This seems to be painfully required...

  #+begin_src emacs-lisp
    (require 'cl)
  #+end_src

* Custom

  I don't particularly like custom, but hey, it's here.

  #+begin_src emacs-lisp
    (setq custom-file "~/.emacs.d/custom.el")
    (unless (file-exists-p custom-file)
      (with-temp-buffer (write-file custom-file)))
    (load custom-file)
  #+end_src

* Package configuration
** Path configuration

   This sets up so that packages and themes can be loaded properly.

   #+begin_src emacs-lisp
     (add-to-list 'load-path (concat user-emacs-directory "lisp"))

     (setq custom-theme-directory (concat user-emacs-directory "themes"))

     (dolist
         (path (directory-files custom-theme-directory t "\\w+"))
       (when (file-directory-p path)
         (add-to-list 'custom-theme-load-path path)))
   #+end_src

** Preamble and setup

   Sets up the repositories to get packages from. Extra and more frequently
   updated repositories outside of MELPA are added. Order matters.

   #+begin_src emacs-lisp
     (require 'package)

     (setq package-archives
           '(("org"          . "http://orgmode.org/elpa/")
             ("tromey"       . "http://tromey.com/elpa/")
             ("gnu"          . "http://elpa.gnu.org/packages/")
             ("melpa"        . "http://melpa.org/packages/")
             ("melpa-stable" . "http://stable.melpa.org/packages/")
             ("marmalade"    . "http://marmalade-repo.org/packages/")))

     (package-initialize)
   #+end_src

** use-package

   Using [[https://github.com/jwiegley/use-package][use-package]] to automatically install certain packages, as
   well as the ease of lazily loading them.

   #+begin_src emacs-lisp
     (unless (package-installed-p 'use-package)
       (package-refresh-contents)
       (package-install 'use-package))

     (setq use-package-always-ensure t)
     (require 'use-package)
   #+end_src

* Libraries

  These make working with emacs a bit more pleasurable and modern.

  #+begin_src emacs-lisp
    (use-package cl-lib)
    (use-package dash)
    (use-package f)
    (use-package s)
    (use-package hydra)
    (use-package ivy)
  #+end_src

* Interface
** all-the-icons

   #+begin_src emacs-lisp
     (use-package all-the-icons
       :config
       (use-package all-the-icons-dired
         :config
         (add-hook 'dired-mode-hook 'all-the-icons-dired-mode)))
   #+end_src

** avy

   avy is a nice little package that helps with quick navigation. Using =C-l=
   you get a prompt for a character. Press one and that character will get
   guiding characters that help you move to a specific one in a keystroke. Try
   it out and you might change your movement habits forever.

   #+begin_src emacs-lisp
     (use-package avy
       :ensure t
       :commands avy-goto-word-1 avy-goto-char-1 avy-goto-line avy-goto-char-timer
       :bind
       ("C-l"     . avy-goto-word-1))
   #+end_src

** darktooth

   I really like the darktooth theme! This sets that up and also makes some
   overrides. As much as I like it, it has some things I want to improve on!

   #+begin_src emacs-lisp
     (use-package darktooth-theme
       :ensure t)

     (load-theme 'darktooth)

     ;; On the workstation, the font should be big. Elsewhere, make it smaller.
     (set-frame-font
      (if (s-equals? (system-name) "dragonwing")
          "Iosevka-12"
        "Iosevka-10"))

     ;; This is called at the very bottom of emacs.org. See comments there.
     (defun th/fix-darktooth ()
       "Things that make darktooth a theme more suited for me."

       (let ((faces (face-list)))
         ;; This is to fix the lack of boldness in darktooth
         (mapc
          (lambda (face)
            (set-face-attribute face nil ':bold t))
          (-filter
           (lambda (face)
             (let ((fn (symbol-name face)))
               (or (s-starts-with? "font-lock" fn)
                   (s-starts-with? "org-level" fn)
                   (s-starts-with? "rainbow" fn))))
           faces))

         ;; This is to fix the fact that darktooth has foreground colorization for
         ;; avy, which to my eyes don't stick out enough.
         (mapc
          (lambda (face)
            (set-face-attribute face nil ':inverse-video t))
          (-filter
           (lambda (face)
             (let ((fn (symbol-name face)))
               (s-starts-with? "avy-lead" fn)))
           faces)))

       ;; Also make the linum and the fringe stand out more!
       (set-face-attribute 'linum nil :background "#1D2021" :foreground "#7C6F64")
       (set-face-attribute 'fringe nil :background "#3C3836")

       ;; Also strings and types are the same, which is bad. Make strings greener.
       (set-face-attribute 'font-lock-string-face nil :foreground "#427B58")
       ;; And functions do not stand out at all...
       (set-face-attribute 'font-lock-function-name-face nil :foreground "#FE8019")

       (message "darktooth fixed"))
   #+end_src

** popwin

   popwin is a little library that makes most special kinds of buffers appear
   as smaller popups rather than just take up the entire space of a buffer.

   #+begin_src emacs-lisp
     (use-package popwin
       :bind
       ("C-x C-k" . popwin:close-popup-window)

       :config
       (popwin-mode 1)
       ;; It was apparently tricky to make use-package map to what's just a keymap
       (global-set-key (kbd "C-x p") popwin:keymap))
   #+end_src

** projectile

   projectile brings knowledge of your different projects into emacs. Sadly, I
   mostly only use =C-c p p=, which brings up a helm selector for all visited
   projects. projectile itself is much more powerful than that, I just never
   got around to using it much more.

   #+begin_src emacs-lisp
     (use-package projectile
       :bind (("C-x f" . projectile-find-file))
       :bind-keymap (("C-x p" . projectile-command-map))
       :commands (projectile-switch-project)
       :demand

       :config
       (projectile-global-mode)
       (setq projectile-completion-system 'ivy
             projectile-mode-line nil))
   #+end_src

** Swiper / ivy / counsel

   [[https://github.com/abo-abo/swiper][swiper]] is a fuzzy completion library similar to helm, but is lighter, tons
   simpler to use and much easier to extend.

*** Base setup

   #+begin_src emacs-lisp
     (use-package ivy
       :bind (("M-x"     . counsel-M-x)
              ("C-x y"   . counsel-yank-pop)
              ("C-c C-r" . ivy-resume))
       :commands (ivy-set-actions)
       :config
       (setq ivy-use-virtual-buffers t)
       (setq ivy-count-format "(%d/%d) ")
       (setq ivy-height 20)
       (setq magit-completing-read-function 'ivy-completing-read)

       ;; So that we can do space separation in file name completions
       (setq ivy-re-builders-alist
             '((t . ivy--regex-ignore-order)))

       (ivy-mode 1))

     (use-package counsel
       :bind (("C-x M-p" . counsel-package))
       :config
       ;; https://github.com/abo-abo/swiper/issues/685#issuecomment-249162962
       (setq counsel-find-file-ignore-regexp
             (concat
              ;; File names beginning with # or .
              "\\(?:\\`[#.]\\)"
              ;; File names ending with # or ~
              "\\|\\(?:\\`.+?[#~]\\'\\)")))

     (defhydra th/search-hydra (:exit t :foreign-keys warn)
       "Searching"
       ("C-s" counsel-grep-or-swiper "search")
       ("s" counsel-grep-or-swiper "search")
       ("a" swiper-all "all")
       ("g" counsel-git-grep "git grep")
       ("i" counsel-imenu "imenu")
       ("k" counsel-descbinds "keys"))

     (global-set-key (kbd "C-s") 'th/search-hydra/body)
   #+end_src

*** Custom actions

    These commands add so that the z/s actions in buffer switching and file
    switching opens in a new split of the corresponding kind. I've missed this
    since I switched to emacs 18 months ago, damn.

    #+begin_src emacs-lisp
      (ivy-set-actions
       'projectile-find-file
       '(("z" (lambda (fn)
                (interactive)
                (split-window-below)
                (windmove-down)
                (find-file fn))
          "horz")
         ("s" (lambda (fn)
                (interactive)
                (split-window-right)
                (windmove-right)
                (find-file fn))
          "vert")))

      (ivy-set-actions
       'ivy-switch-buffer
       '(("z" (lambda (buf)
                (interactive)
                (split-window-below)
                (windmove-down)
                (switch-to-buffer buf))
          "horz")

         ("s" (lambda (buf)
                (interactive)
                (split-window-right)
                (windmove-right)
                (switch-to-buffer buf))
          "vert")

         ("d" (lambda (buf)
                (interactive)
                (kill-buffer buf)
                (message "Buffer %s killed" buf))
          "delete")))
    #+end_src

* Editing
** Adding current buffer to minibuffer

   Press =F3= to insert the full path of the current buffer into the
   minibuffer.

   #+begin_src emacs-lisp
     (define-key minibuffer-local-map [f3]
       (lambda () (interactive)
         (insert (file-truename
                  (buffer-name
                   (window-buffer (minibuffer-selected-window)))))))

   #+end_src

** Autocompletion

   #+begin_src emacs-lisp
     (use-package company
       :config
       ;; Let company do its thing as often as possible.
       (global-company-mode t)

       (setq company-tooltip-limit 20)       ; bigger popup window
       (setq company-idle-delay .3) ; decrease delay before autocompletion popup shows
       (setq company-echo-delay 0)  ; remove annoying blinking
       (setq company-begin-commands '(self-insert-command)) ; start autocompletion only after typing
       )

     (use-package company-go)
   #+end_src

** Commenting code

   Comments lines or regions.

   #+begin_src emacs-lisp
     (defun th/comment-block ()
       (interactive)
       (let ((start (line-beginning-position))
             (end (line-end-position)))
         (when (region-active-p)
           (setq start (save-excursion
                         (goto-char (region-beginning))
                         (beginning-of-line)
                         (point))
                 end (save-excursion
                       (goto-char (region-end))
                       (end-of-line)
                       (point))))
         (comment-or-uncomment-region start end)))

     (global-set-key (kbd "M-;") 'th/comment-block)
   #+end_src

** Enhanced default keybindings
*** C-a

    #+begin_src emacs-lisp
      (defun back-to-indentation-or-bol ()
        "Go to first non whitespace character on a line, or if already on the first
        non whitespace character, go to the beginning of the previous non-blank line."
        (interactive)
        (if (= (point)
               (save-excursion
                 (back-to-indentation)
                 (point)))
            (beginning-of-line)
          (back-to-indentation)))

      (global-set-key (kbd "C-a") 'back-to-indentation-or-bol)
    #+end_src

*** C-e

    #+begin_src emacs-lisp
      (defun th/eol-or-bol ()
        (interactive)
        (if (eolp)
            (back-to-indentation)
          (move-end-of-line nil)))

      (global-set-key (kbd "C-e") 'th/eol-or-bol)
    #+end_src

*** C-o and C-M-o
#+begin_src emacs-lisp
  (defun insertline-and-move-to-line (&optional up)
    "Insert a newline, either below or above depending on `up`. Indent accordingly."
    (interactive)
    (beginning-of-line)
    (if up
        (progn
          (newline)
          (forward-line -1))
      (move-end-of-line nil)
      (open-line 1)
      (forward-line 1))
    (indent-according-to-mode))

  (global-set-key (kbd "C-o") 'insertline-and-move-to-line)
  (global-set-key (kbd "C-M-o") (lambda ()
                                  (interactive)
                                  (insertline-and-move-to-line t)))
#+end_src
** Entire line operation

   #+begin_src emacs-lisp
     (global-set-key (kbd "M-k")
                     (lambda ()
                       (interactive)
                       (beginning-of-line)
                       (if (eq (point) (point-max))
                           (previous-line))
                       (kill-line 1)
                       (back-to-indentation)))

     (defun yank-entire-line ()
       (interactive)
       (save-excursion
         (beginning-of-line)
         (set-mark-command)
         (end-of-line)
         (kill-ring-save)))

   #+end_src

** hungry-delete

   Delete all spaces instead of just a little bit

   #+begin_src emacs-lisp
     (use-package hungry-delete
       :config
       (global-hungry-delete-mode))
   #+end_src

** fill mode
#+begin_src emacs-lisp
  (auto-fill-mode 1)
  (set-fill-column 79)
#+end_src

** Joining lines

   The default behavior didn't really sit well with me.

   #+begin_src emacs-lisp
     (global-set-key (kbd "M-j") (lambda () (interactive) (join-line -1)))
   #+end_src

** Line duplication

   Duplicates a line or the current region. Is smart about copying the lines
   and not just where the region started or ended.

   #+begin_src emacs-lisp
     (defun duplicate-current-line-or-region (arg)
       "Duplicates the current line or region ARG times.
        If there's no region, the current line will be duplicated. However, if
        there's a region, all lines that region covers will be duplicated."
       (interactive "p")
       (let (beg end (origin (point)))
         (if (and mark-active (> (point) (mark)))
             (exchange-point-and-mark))
         (setq beg (line-beginning-position))
         (if mark-active
             (exchange-point-and-mark))
         (setq end (line-end-position))
         (let ((region (buffer-substring-no-properties beg end)))
           (dotimes (i arg)
             (goto-char end)
             (newline)
             (insert region)
             (setq end (point)))
           (goto-char (+ origin (* (length region) arg) arg)))))

     (global-set-key (kbd "C-x d") 'duplicate-current-line-or-region) ; fak u paredit <3
   #+end_src

** Save hooks

   Delete trailing whitespace on save. Also truncates empty lines at the end
   of the file.

   #+begin_src emacs-lisp
     (add-hook 'before-save-hook
               (lambda ()
                 (save-excursion
                   (save-restriction
                     (delete-trailing-whitespace)
                     (widen)
                     (goto-char (point-max))
                     (delete-blank-lines)))))
   #+end_src

** undo tree

   Visualizes states of undo. Really nice when you want to backtrack a bit to
   get an overview of what you just messed up.

   #+begin_src emacs-lisp
     (use-package undo-tree
       :bind
       (("C-z"     . undo-tree-undo)
        ("C-x C-z" . undo-tree-undo)
        ("C-M-z"   . undo-tree-redo)
        ("C-x u"   . undo-tree-visualize))

       :config
       (global-undo-tree-mode +1))
   #+end_src

** yas

   The canonical snippet library for emacs. Mostly works well, although it can
   come with questionable defaults every now and again.

   #+begin_src emacs-lisp
     (use-package yasnippet
       :config
       (yas-reload-all) ;; Without this, it doesn't load...
       (add-hook 'prog-mode-hook 'yas-minor-mode)
       (add-hook 'markdown-mode 'yas-minor-mode)
       (add-hook 'org-mode-hook 'yas-minor-mode))

     (defhydra th/yas-hydra (:exit t)
       "yas"
       ("s" yas-insert-snippet "snippet")
       ("M-s" yas-insert-snippet "snippet")
       ("c" yas-new-snippet "new")
       ("n" yas-new-snippet "new")
       ("v" yas-visit-snippet-file "visit"))

     (global-set-key (kbd "M-s") 'th/yas-hydra/body)
   #+end_src

* Major modes
** compile

   The compilation concept inside of emacs is great, but its defaults is a
   tad... old fashioned.

*** Settings

    #+begin_src emacs-lisp
      (use-package compile
        :bind (:map compilation-mode-map
               ("q" . th/quit-compilation-buffer)
               ;; `C-c l` is because that same command is used in golang and others
               ("C-c l" . th/toggle-maximize-buffer)

               :map go-mode-map
               ("C-c l" . th/maximize-log))

        :init
        (add-to-list 'comint-output-filter-functions 'ansi-color-process-output)

        (setq compilation-always-kill t
              compilation-ask-about-save nil
              compilation-auto-jump-to-first-error nil
              compilation-scroll-output t)

        (defun th/toggle-maximize-buffer (&optional buffer-name)
          "Maximize buffer"
          (interactive)
          (if (= 1 (length (window-list)))
              (jump-to-register '_)
            (progn
              (window-configuration-to-register '_)
              (if buffer-name
                  (switch-to-buffer buffer-name))
              (delete-other-windows))))

        (defun th/maximize-log ()
          (interactive)
          (th/toggle-maximize-buffer "*compilation*"))

        (defun th/quit-compilation-buffer ()
          ;; TODO: Maybe this can be done with advice instead?
          (interactive)
          (if (= 1 (length (window-list)))
              (jump-to-register '_)
            (quit-window))))
    #+end_src

** elfeed

   #+begin_src emacs-lisp
     (use-package elfeed
        :ensure t
        :bind (:map elfeed-search-mode-map
                    ("a" . elfeed-add-feed)
                    ("G" . elfeed-update)
                    ("q" . bjm/elfeed-save-db-and-bury)
                    ("Q" . bjm/elfeed-save-db-and-bury)
                    ("j" . mz/make-and-run-elfeed-hydra)
                    ("J" . mz/make-and-run-elfeed-hydra)
                    ("m" . elfeed-toggle-star)
                    ("M" . elfeed-toggle-star)))

      (use-package elfeed-goodies
        :ensure t
        :config
        (elfeed-goodies/setup))
      ;; (setq elfeed-db-directory "~/Dropbox/shared/elfeeddb")

      (defun elfeed-mark-all-as-read ()
        (interactive)
        (mark-whole-buffer)
        (elfeed-search-untag-all-unread))

      ;;functions to support syncing .elfeed between machines
      ;;makes sure elfeed reads index from disk before launching
      (defun bjm/elfeed-load-db-and-open ()
        "Wrapper to load the elfeed db from disk before opening"
        (interactive)
        (elfeed-db-load)
        (elfeed)
        (elfeed-search-update--force))

      ;;write to disk when quiting
      (defun bjm/elfeed-save-db-and-bury ()
        "Wrapper to save the elfeed db to disk before burying buffer"
        (interactive)
        (elfeed-db-save)
        (quit-window))

      (defalias 'elfeed-toggle-star
        (elfeed-expose #'elfeed-search-toggle-all 'star))



      (use-package elfeed-org
        :ensure t
        :config
        (elfeed-org)
        (setq rmh-elfeed-org-files nil))

      (defun z/hasCap (s)
        ""
        (let ((case-fold-search nil))
          (string-match-p "[[:upper:]]" s)))


      (defun z/get-hydra-option-key (s)
        "returns single upper case letter (converted to lower) or first"
        (interactive)
        (let ((loc (z/hasCap s)))
          (if loc
              (downcase (substring s loc (+ loc 1)))
            (substring s 0 1))))

      (defun mz/make-elfeed-cats (tags)
        "Returns a list of lists. Each one is line for the hydra configuratio in the form
           (c function hint)"
        (interactive)
        (mapcar (lambda (tag)
                  (let* (
                         (tagstring (symbol-name tag))
                         (c (z/get-hydra-option-key tagstring))
                         )
                    (list c (append '(elfeed-search-set-filter) (list (format "@6-months-ago +%s" tagstring) ))tagstring  )))
                tags))

      (defmacro mz/make-elfeed-hydra ()
        `(defhydra mz/hydra-elfeed ()
           "filter"
           ,@(mz/make-elfeed-cats (elfeed-db-get-all-tags))
           ("*" (elfeed-search-set-filter "@6-months-ago +star") "Starred")
           ("M" elfeed-toggle-star "Mark")
           ("A" (elfeed-search-set-filter "@6-months-ago") "All")
           ("T" (elfeed-search-set-filter "@1-day-ago") "Today")
           ("Q" bjm/elfeed-save-db-and-bury "Quit Elfeed" :color blue)
           ("q" nil "quit" :color blue)
           ))

      (defun mz/make-and-run-elfeed-hydra ()
        ""
        (interactive)
        (mz/make-elfeed-hydra)
        (mz/hydra-elfeed/body))
   #+end_src

** elisp

   Options and settings for hacking on emacs itself.

   #+begin_src emacs-lisp
     (use-package lispy
       :bind (:map lispy-mode-map
                   ;; This one just needs to be overwritten
                   ("M-o" . th/org/body)))

     (add-hook 'emacs-lisp-mode-hook 'lispy-mode)
     (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
     (add-hook 'emacs-lisp-mode-hook 'paredit-mode)
     (add-hook 'emacs-lisp-mode-hook 'rainbow-identifiers-mode)
     (add-hook 'emacs-lisp-mode-hook 'prettify-symbols-mode)

     ;; pls no .elc
     (add-hook
      'emacs-lisp-mode-hook
      (lambda ()
        (make-local-variable 'after-save-hook)
        (add-hook
         'after-save-hook
         (lambda ()
           (if (file-exists-p (concat buffer-file-name "c"))
               (delete-file (concat buffer-file-name "c")))))))

     (defun th/buffer-or-region (action-name buffer-func region-func)
       (let ((s "Buffer"))
         (if (use-region-p)
             (progn
               (funcall region-func (region-beginning) (region-end))
               (keyboard-escape-quit)
               (setq s "Region"))
           (funcall buffer-func))

         (message "buffer-or-region: %s %s" s action-name)))

     (defun eval-buffer-or-region ()
       (interactive)
       (th/buffer-or-region "eval" 'eval-buffer 'eval-region))

     (define-key emacs-lisp-mode-map (kbd "C-c C-e") 'eval-buffer-or-region)
   #+end_src

** hydra

   #+begin_src emacs-lisp
     (use-package hydra)
   #+end_src

** logview-mode

   Nifty little mode that makes reading structured logs easier.

   #+begin_src emacs-lisp
     (use-package logview)
   #+end_src

** makefile

   A few additions to makefile-mode. =C-c C-c= presents a choice of all of the
   targets in the current makefile and runs it with =compile=.

   #+begin_src emacs-lisp
     (require 'make-mode)

     ;; The \n and the subsequent hard tab are put there since org-src is trying to
     ;; be smart and converts the tab to spaces, which make really disagrees with.
     ;; Tabs in makefiles are possibly the saddest point of tech debt ever.
     (defvar makefile-list-target "# Listing all the make targets; http://stackoverflow.com/a/26339924/983746
      .PHONY: list
      list:\n	@$(MAKE) -pRrq -f $(lastword $(MAKEFILE_LIST)) : 2>/dev/null | awk -v RS= -F: '/^# File/,/^# Finished Make data base/ {if ($$1 !~ \"^[#.]\") {print $$1}}' | sort | egrep -v -e '^[^[:alnum:]]' -e '^$@$$'\n"
       "Definition of target used to list makefile targets.")

     (defun makefile-execute-target ()
       "Presents a `completing-read' of all the targets of a makefile and executes
      the chosen one. "
       (interactive)

       (let ((fn (buffer-file-name)))
         (compile
          (format
           "make -f %s %s" fn
           (completing-read "target: " (makefile-get-targets fn) nil t)))))

     (define-key makefile-mode-map (kbd "C-c C-c") 'makefile-execute-target)

     (defun makefile-get-targets (fn)
       "Returns a list of all the targets of a makefile.

      To list them in a computed manner, a new target called \"list\" is added and
      the buffer is written to a temporary file."
       (let* ((file (make-temp-file "makefile"))
              (makefile-contents
               (concat
                (with-temp-buffer (insert-file-contents fn) (buffer-string))
                "\n\n"
                makefile-list-target)))
         (f-write-text makefile-contents 'utf-8 file)

         (with-temp-buffer
           (shell-command
            (format "make -f %s list" file)
            (current-buffer))
           (delete-file file)
           (s-split "\n" (buffer-string) t))))
   #+end_src

** org

   One of the obvious killer features of emacs! org is the kind of thing that
   makes emacs users into obnoxious cultists, but it is for a reason! Once you
   get into it, it'll be hard to look back.

*** Main setup

    #+begin_src emacs-lisp
      (use-package org
        :bind (:map org-mode-map
                    ("C-c ;" . org-edit-special)
               :map org-src-mode-map
                    ("C-c ;" . org-edit-src-exit))

        :init
        (setq
         org-confirm-babel-evaluate nil
         org-directory "~/org"
         org-fontify-emphasized-text t ;; fontify *bold* _underline_ /italic/ and so on
         org-hide-leading-stars t
         org-return-follows-link t
         org-special-ctrl-a/e t
         org-special-ctrl-k t
         org-src-fontify-natively t
         org-src-tab-acts-natively t
         org-src-window-setup 'current-window
         org-use-speed-commands t
         org-imenu-depth 5

         ;; When calculating percentages of checkboxes, count all boxes, not just
         ;; direct children
         org-hierarchical-checkbox-statistics t)

        :config
        (org-babel-do-load-languages
         'org-babel-load-languages
         '((emacs-lisp . t)
           (sql . t)
           (shell . t)
           (python . t)
           (js . t)))

        (org-bullets-mode 1))

      (use-package org-journal)
    #+end_src

*** Agenda and todo
**** Settings and options

     #+begin_src emacs-lisp
       (global-set-key (kbd "C-c a") 'org-agenda)

       (setq
        org-agenda-ndays 7
        org-agenda-files '("~/org/")
        org-agenda-show-all-dates t
        org-agenda-start-on-weekday nil
        org-archive-location "~/org/archive/%s::"
        org-log-done t) ;;timestamp when switching from todo to done

       (setq org-todo-keywords
             '("TODO(t)" "WORKING(w)" "WAITING(z)" "REVIEW(r)" "|" "DONE(d)" "INVALID(i)"))

       (setq org-todo-keyword-faces '(("WORKING" . org-scheduled-today)
                                      ("WAITING" . org-mode-line-clock)))

     #+end_src

**** Journal

     #+begin_src emacs-lisp
       (setq org-journal-dir "~/org/journal/"
             org-journal-file-format "%Y-%m-%d"
             org-journal-date-format "%A, %Y-%m-%d"
             org-journal-find-file 'find-file)

       ;; Since I am planning to do a lot of these, let's just pick a super simple keybind!
       (global-set-key (kbd "C-.") 'org-journal-new-entry)
     #+end_src

**** Capturing

     #+begin_src emacs-lisp
       (setq
        org-capture-templates
        `(("t" "Tasks" entry
           (file+headline "~/org/inbox.org" "Inbox")
           "* TODO %^{Task}")

          ("T" "Quick task" entry
           (file+headline "~/org/inbox.org" "Inbox")
           "* TODO %^{Task}\nSCHEDULED: %t\n"
           :immediate-finish t)

          ("i" "Interrupting task" entry
           (file+headline "~/org/inbox.org" "Inbox")
           "* STARTED %^{Task}"
           :clock-in :clock-resume)

          ("e" "Emacs idea" entry
           (file+headline "~/org/inbox.org" "Emacs")
           "* TODO %^{Task}"
           :immediate-finish t)

          ("E" "Event" entry
           (file+datetree+prompt "~/org/events.org" "Event")
           "* TODO %^{Task}\nSCHEDULED: %<%Y-%m-%d %H:%M>"
           :immediate-finish t)

          ("q" "Quick note" item
           (file+headline "~/org/inbox.org" "Quick notes"))

          ("r" "Recipe" entry
           (file+headline "~/org/food.org" "Recipes")
           "* [[%^{URL}][%^{Title}]]"
           )))
     #+end_src

**** Toggler keybindings

     #+begin_src emacs-lisp
       (define-key org-mode-map (kbd "C-c t")
         (lambda ()
           (interactive)
           (org-todo "TODO")))

       (define-key org-mode-map (kbd "C-c w")
         (lambda ()
           (interactive)
           (org-todo "WORKING")))

       (define-key org-mode-map (kbd "C-c z")
         (lambda ()
           (interactive)
           (org-todo "WAITING")))

       (define-key org-mode-map (kbd "C-c r")
         (lambda ()
           (interactive)
           (org-todo "REVIEW")))

       (define-key org-mode-map (kbd "C-c d")
         (lambda ()
           (interactive)
           (org-todo "DONE")))

       (define-key org-mode-map (kbd "C-c i")
         (lambda ()
           (interactive)
           (org-todo "INVALID")))

       (define-key org-mode-map (kbd "C-c SPC")
         (lambda ()
           (interactive)
           (org-todo 'none)))

     #+end_src

**** org-goto-for-project

     #+begin_src emacs-lisp
       (defun th/org-project ()
         "Go to the org project for the current repository.

       Go back if we're already in it."

         (interactive)
         (let* ((root (projectile-project-root))
                (name (car (last (s-split "/" (projectile-project-root)) 2))))
           (if (s-equals? (expand-file-name "~/org/") root)
               (progn
                 (save-buffer)
                 (previous-buffer))
             (find-file
              (format "~/org/%s.org" name)))))

     #+end_src

**** Archiving

     #+begin_src emacs-lisp
       (defun org-archive-done-tasks ()
         (interactive)
         (org-map-entries
          (lambda ()
            (org-archive-subtree)
            (setq org-map-continue-from (outline-previous-heading)))
          "/DONE" 'file))

       (define-key org-mode-map (kbd "C-c C-x C-a") 'org-archive-done-tasks)
     #+end_src

*** Hydra commands

    #+begin_src emacs-lisp
      (defhydra th/org (:exit t)
        "Org commands"
        ("C-o" th/org-project "Project file")
        ("c" org-capture "Capture")
        ("o" org-capture "Capture")
        ("s" (org-agenda nil "a") "Schedule")
        ("i" (find-file "~/org/inbox.org") "Inbox")
        ("j" org-clock-goto "Current clocked task")
        ("a" org-todo-list "Agenda")
        ("t" org-tags-view "Tags"))

      (global-set-key (kbd "C-x C-o") 'th/org/body)
    #+end_src

*** worf

    Smoother org mode speed key bindings

    #+begin_src emacs-lisp
      (use-package worf)

      (add-hook 'org-mode-hook 'worf-mode)
    #+end_src

** prog-mode

   Hooks that are needed for programming modes.

   #+begin_src emacs-lisp
     ;; Semantic
     (add-hook 'emacs-lisp-mode-hook 'semantic-mode)
     (add-hook 'go-mode-hook 'semantic-mode)
     (add-hook 'python-mode-hook 'semantic-mode)

     (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
     (add-hook 'prog-mode-hook (lambda ()
                                 (auto-save-mode -1)))
     (add-hook 'text-mode-hook 'turn-on-fci-mode)
     (add-hook 'text-mode-hook 'auto-fill-mode)
     (add-hook 'prog-mode-hook 'auto-fill-mode)
   #+end_src

** python

   The major mode for editing Python in emacs. It honestly doesn't have much
   going for it, but hey.

   #+begin_src emacs-lisp
     (use-package python-mode
       :config
       (add-hook 'python-mode-hook 'flycheck-mode)
       (setq-default py-split-windows-on-execute-p nil))

     (use-package anaconda-mode
       :config
       (add-hook 'python-mode-hook 'anaconda-mode))

     (use-package pip-requirements)
     (use-package virtualenvwrapper
       :config
       (venv-initialize-eshell))
   #+end_src

*** TODO Configure a working company backend

** Racket

   Lisp lovin' <3

   #+begin_src emacs-lisp
     (use-package racket-mode)
   #+end_src

** Utility modes

   Several modes that I just install to have, without configuring. Grouped
   together because why not.

   #+begin_src emacs-lisp
     (use-package crontab-mode)
     (use-package csv-mode)
     (use-package fish-mode)
     (use-package markdown-mode)
     (use-package nginx-mode)
     (use-package protobuf-mode)
     (use-package puppet-mode)
     (use-package ssh-config-mode)
     (use-package yaml-mode)
   #+end_src

** web-mode / vue-mode

   Enhanced editing of HTML with support for embedded languages.
   Used by vue-mode for templates.

*** Default setup

    #+begin_src emacs-lisp
      (use-package vue-mode)

      (use-package web-mode
        :init
        (setq web-mode-markup-indent-offset 2
              web-mode-attr-indent-offset 2)
        :config
        (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
        ;; If we're in vue-mode, make sure to reset it when we save.
        (add-hook 'after-save-hook
                  (lambda ()
                    (interactive)
                    (when (eq 'vue-mode major-mode)
                      (vue-mode)))))
    #+end_src

*** Browse to vue files only

    #+begin_src emacs-lisp
      (global-set-key (kbd "C-c v")
                      (lambda ()
                        (interactive)
                        (th/other-files-suffix "vue")))
    #+end_src

* Minor modes and utilities
** Alternate file visiting
*** Other files with same extension

    #+begin_src emacs-lisp
      (defun th/other-files-suffix (&optional suffix)
        "Browse between files of a certain kind in the current project.
      Defaults to the suffix of the current buffer if none is given.

      E.g. if you are visiting a .go file, this will list all other .go files.

      This is useful if you have backend and frontend code in the same repo."

        (interactive)
        (find-file
         (concat
          (projectile-project-root)
          (let* ((suf (or suffix (f-ext (buffer-file-name))))
                (default-directory (projectile-project-root))
                (targets (-filter
                          (lambda (x)
                            (and
                             (s-suffix? (concat "." suf) x)
                             ;; Filter out test files, backup files and the current file
                             ;; (not (s-contains? "test" x))
                             (not (s-contains? ".#" x))
                             (not (s-contains? x (buffer-file-name)))))
                          (projectile-get-repo-files))))

            (cond
             ((= (length targets) 1)
              (car targets))
             ((= (length targets) 0)
              (error (format "No other %s files" suf)))
             (t
              (completing-read
               (format "%s files: " suf)
               targets)))))))

      (global-set-key (kbd "C-x a") 'th/other-files-suffix)
    #+end_src

*** Other files with the same base name

    #+begin_src emacs-lisp
      (defun th/other-files-same-base ()
        "Find other files that have the same base as the current
      one. Complete if there are multiple found.

      E.g. if you are visiting `user.go' and `User.vue' exists, visit
      that. If there is also a `UserPanel.vue', start completion
      between the matching files instead.

      This is useful if you have backend and frontend code in the same repo."

        (interactive)

        (let* ((base (f-base (buffer-file-name)))
               (default-directory (projectile-project-root))
               (files (-filter
                       (lambda (x)
                         (and
                          (s-prefix? (downcase base)
                                     (downcase (f-base (f-filename x))))
                          ;; Filter out test files, backup files and the current file
                          (not (s-contains? "test" x))
                          (not (s-contains? ".#" x))
                          (not (s-contains? x (buffer-file-name)))))
                       (projectile-get-repo-files))))
          (cond
           ((= (length files) 1)
            (find-file (car files)))

           ((> (length files) 1)
            (find-file
             (completing-read "Alt files: " files)))

           (t
            (error "No alternate file for %s" (buffer-name))))))

      (global-set-key (kbd "C-x C-a") 'th/other-files-same-base)
    #+end_src

** Buffer toggles

   F1: `helm-descbinds` (set from helm config above)
   F2: Open this file
   F3: Open main org file
   F4: Scratch buffer
   F5: Toggle debug mode
   C-x ?: Print current file name relative to project root

*** Functions

    #+begin_src emacs-lisp
      (defun th/toggle-buffer (func name &optional kill-window)
        "Toggle or destroy a buffer, depending on if it exists or not.

        The `func` argument should be a callable that toggles the buffer.
        The `name` argument is a substring of the buffer that should be matched."
        (interactive)
        (let ((done nil))
          (loop for buffer being the buffers
                do (let ((bname (buffer-name buffer)))
                     (when (s-contains? name bname)
                       (if kill-window
                           (progn
                             (select-window (get-buffer-window buffer))
                             (kill-buffer-and-window)
                             (message "Killed %s" bname))
                         (progn
                           (kill-buffer buffer)
                           (message "%s toggled away" bname)))
                       (setq done t))))
          (unless done
            (funcall func))))

      (defun th/toggle-file (path &optional no-save)
        (let ((file (file-truename path)))
          (if (s-equals? file buffer-file-name)
              (progn
                (when (not no-save)
                  (save-buffer))
                (previous-buffer))
            (find-file file))))

      (defun th/echo-file-name ()
        (interactive)
        (message
         (s-chop-prefix
          (projectile-project-root)
          (file-truename (buffer-name)))))

      (defun switch-to-previous-buffer ()
        "Switch to previously open buffer.
      Repeated invocations toggle between the two most recently open buffers."
        (interactive)
        (switch-to-buffer (other-buffer (current-buffer) 1)))

      (global-set-key (kbd "C-x C-b") 'switch-to-previous-buffer)

      (defun th/dired-menu ()
        "Go to one of the currently open dired buffers (if there is one)."
        (interactive)
        (let* ((dired-buffers (--map (buffer-name it)
                                     (--filter
                                      (equal 'dired-mode (with-current-buffer it major-mode))
                                      (buffer-list)))))
          (if dired-buffers
              (switch-to-buffer (completing-read "Select dired: " dired-buffers))
            (message "There's no dired buffers open right now"))))

      (global-set-key (kbd "C-x M-d") 'th/dired-menu)

      (global-set-key (kbd "C-x M-b") 'ibuffer)
    #+end_src

*** Keymaps

    #+begin_src emacs-lisp
      (define-key global-map (kbd "<f2>")
        (lambda ()
          (interactive)
          (th/toggle-file (concat user-emacs-directory "emacs.org"))))

      (define-key global-map (kbd "C-x <f2>")
        (lambda ()
          (interactive)
          (split-window-below)
          (balance-windows)
          (windmove-down)
          (th/toggle-file (concat user-emacs-directory "emacs.org"))))

      (define-key global-map (kbd "<f3>")
        (lambda ()
          (interactive)
          (th/toggle-file "~/.logs/payments/info.log" t)
          (end-of-buffer)))

      (define-key global-map (kbd "<f4>")
        (lambda ()
          (interactive)
          (let ((content initial-scratch-message)
                (buf "*scratch*"))
            (when (get-buffer buf)
              (setq content ""))
            (switch-to-buffer buf)
            (insert content))))

      (define-key global-map (kbd "<f5>")
        (lambda ()
          (interactive)
          (let ((doe t))
            (if debug-on-error
                (setq doe nil))
            (setq debug-on-error doe)
            (message "debug-on-error set to %s" doe))))

      (define-key global-map (kbd "C-x ?") 'th/echo-file-name)
    #+end_src

** Configurationless utilities

   These are tools that are useful just by dropping them in and not doing any
   further configuration on them.

*** adaptive-wrap

    Nice little minor mode that visually aligns wrapping smarter than just in
    the beginning of the line.

    #+begin_src emacs-lisp
      (use-package adaptive-wrap)
    #+end_src

*** buffer-move

    Switch places of buffers.

    #+begin_src emacs-lisp
      (use-package buffer-move)
    #+end_src

*** diminish

    Clean up the modeline by removing certain minor modes.

    #+begin_src emacs-lisp
      (use-package diminish)
    #+end_src

*** fill-column-indicator

    Show a line at the end where the =wrap-column= ends.

    #+begin_src emacs-lisp
      (use-package fill-column-indicator)
    #+end_src

*** paradox

    Nicer list of packages. Supports upgrading and giving stars to github
    repositories.

    #+begin_src emacs-lisp
      (use-package paradox)
    #+end_src

*** paredit

    Powerful lisp editing. Comes with emacs, but updating it is nice.

    #+begin_src emacs-lisp
      (use-package paredit)
    #+end_src

*** restclient

    Nifty package that lets you make requests towards a REST sources and
    displays pretty versions of the responses.

    #+begin_src emacs-lisp
      (use-package restclient
        :mode ("\\.http\\'" . restclient-mode))
    #+end_src

*** transpose-frame

    Move from vertically split to horizontally split frames.

    #+begin_src emacs-lisp
      (use-package transpose-frame)
    #+end_src

*** wrap-region

    Actually this one needs config and shouldn't be here...

    #+begin_src emacs-lisp
      (use-package wrap-region)
    #+end_src

*** xkcd

    View xkcd strips inside of emacs!

    #+begin_src emacs-lisp
      (use-package xkcd)
    #+end_src

** Context aware execution

   Exeucte different things depending on what's under point.

   #+begin_src emacs-lisp
     (defun th/context-execute ()
       "Context aware execution of what's under point"

       (interactive)
       (let ((symbol (th/context-get-whitespace-word)))
         (message "Executing: <%s>" symbol)

         (cond
          ;; JIRA tickets
          ((s-matches? "[A-Z][A-Z]+-[0-9]+" symbol)
           (th/context-visit-jira symbol))

          ;; URLs
          ((s-matches? "[a-z]+://" symbol)
           (browse-url symbol)))

         ))

     (defun th/context-get-whitespace-word ()
       "Get the whitespace delimited word under point."

       (let ((start (save-excursion (re-search-backward "\\(^\\| \\)")))
             (end (save-excursion (re-search-forward "\\( \\|$\\)"))))
         (s-trim (buffer-substring start end))))

     (defun th/context-visit-jira (ticket)
       "Visit the JIRA page"
       (interactive)
       (browse-url (concat th/context-jira-root "/browse/" ticket)))

     (defvar th/context-jira-root "https://jira.spotify.net" "Root URL for JIRA")

     (global-set-key (kbd "M-RET") 'th/context-execute)
     (global-set-key (kbd "C-x RET") 'th/context-execute)
   #+end_src

** company

   Completion backend. Daemon based and ridiculously fast.

   #+begin_src emacs-lisp
     (use-package company
       :config
       (use-package company-flx
         :config
         (company-flx-mode +1)))
   #+end_src

** Docker

   Docker management from inside of emacs!

   #+begin_src emacs-lisp
     (use-package docker
       :bind (("C-x C-d" . docker-containers)
              (:map docker-containers-mode-map
                    ("i" . docker-images))))
     (use-package dockerfile-mode)
     (use-package docker-tramp)
   #+end_src

** editorconfig

   #+begin_src emacs-lisp
     (use-package editorconfig
       :init
       (editorconfig-mode 1))
   #+end_src

** environment-loader

   Take all =export= variables from a =.env= file in the current directory and
   set them into emacs. Useful if you are working with [[https://12factor.net/config][12 factor apps]].

   #+begin_src emacs-lisp
     (defun th/load-env (&optional dir)
       "Loads all environment variables inside of given file into emacs."
       (interactive)

       (let* ((fn (th/find-env-file dir))
              (hash (th/get-env-hash fn))
              (keys (hash-table-keys hash)))
         (mapcar
          (lambda (k)
            (setenv k (gethash k hash)))
          keys)
         (message "Loaded %s.env: %s"
                  (f-base fn)
                  (s-join ", " keys))))

     (defun th/find-env-file (&optional dir)
       "Find the .env file in the current directory.

     If `dir' is given, use that instead of current."

       (when (not dir)
         (setq dir default-directory))

       ;; Fetches the first file if there is only one - completing read if multiple.
       ;; TODO(thiderman): No error handling if there are no files
       (let* ((files (f-files dir
                              (lambda (file)
                                (equal (f-ext file) "env")))))
         (if (= 1 (length files))
             (car files)
           (completing-read "env: " files))))

     (defun th/get-env-hash (fn)
       "For a given filename, return a list of acons of env variables inside."
       (let ((table (make-hash-table :test 'equal)))
         (with-temp-buffer
           (insert-file fn)
           (beginning-of-buffer)
           (mapcar 'th/-put-into-hash
            (th/-get-env-lines-in-file)))
         table))

     (defun th/-put-into-hash (s)
       (let* ((spl (s-split "=" (s-replace "export " "" s)))
              (key (car spl))
              (val (s-replace "\"" "" (cadr spl))))
         ;; `table' is set in the lexical scope of the callee
         (puthash key val table)))

     (defun th/-get-env-lines-in-file ()
       (-filter
        (lambda (s) (s-starts-with? "export" s))
        (s-lines
         (buffer-substring-no-properties (point) (point-max)))))
   #+end_src

** dired

   =dired= seems pretty dated at first, but it's actually quite nice!

   #+begin_src emacs-lisp
     (require 'dired)
     (require 'dired-x)

     (add-hook 'dired-mode-hook 'dired-hide-details-mode)

     (define-key dired-mode-map (kbd "M-r") 'rgrep)

     (setq-default dired-omit-files-p t) ; Buffer-local variable
     (setq dired-omit-files (concat dired-omit-files "\\|^\\..+$\\|.pyc$\\|.sock$"))
     (setq dired-omit-mode t)
     (setq dired-omit-verbose nil) ;; https://open.spotify.com/track/2XRl0NfORYPEvUJXLtJiND
     (setq dired-hide-details-hide-information-lines t)
     (setq dired-hide-details-mode t)
     (setq diredp-hide-details-initially-flag t)
     (setq dired-listing-switches "-alh --group-directories-first")
   #+end_src

** emmet

   =emmet= provides expansion on HTML, so you can write CSS-like strings in
   your HTML files and then do =C-j= and it will expand it out to the full
   tags. Very useful!

   #+begin_src emacs-lisp
     (use-package emmet-mode
       :init
       (setq emmet-indentation 2)

       :config
       (add-hook 'sgml-mode-hook 'emmet-mode)  ;; Auto-start on any markup modes
       (add-hook 'css-mode-hook  'emmet-mode)  ;; Enable Emmet's css abbreviation.
       (add-hook 'web-mode-hook  'emmet-mode))
   #+end_src

** expand-region

   Classic plugin by magnars that manipulates the region based on known
   delimiters.

   #+begin_src emacs-lisp
     (use-package expand-region
       :bind
       ("M-l"   . er/expand-region)
       ("C-M-l" . er/contract-region))
   #+end_src

** ffap

   This is an extended version of =ffap= that will try to find the file at
   point and bring up a preconfigured helm session if nothing can be found.

   #+begin_src emacs-lisp
     ;; This literally has to exist in emacs, I just can't figure out where it is.
     (global-set-key
      (kbd "C-x M-f")
      (lambda ()
        (interactive)
        (let ((fn (ffap-file-at-point))
              (sym (symbol-name (symbol-at-point))))
          (if fn
              (find-file fn)
            (counsel-find-file sym)))))
   #+end_src

** fixme-mode

   Highlight TODO and other related keywords.

   #+begin_src emacs-lisp
     (use-package fixme-mode
       :config
       (add-hook 'prog-mode-hook 'fixme-mode)
       (setq fixme-mode-warning-words
             '("FIXME" "TODO" "BUG" "KLUDGE" "FIX" "FixMe" "HACK"
               "REFACTOR" "NOCOMMIT" "XXX")))
   #+end_src

*** TODO Add support for highlighting labels like TODO(thiderman)

** flycheck

   Error checking and linting done right! Comes pre-packaged for most modes!

   #+begin_src emacs-lisp
     (use-package flycheck
       :bind
       ("C-x C-n" . flycheck-next-error)
       ("C-x C-p" . flycheck-previous-error)

       :config
       (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
   #+end_src

** git and magit
*** git

    Default packages that make git usage pleasant with emacs.

    #+begin_src emacs-lisp
      (use-package gitconfig-mode)
      (use-package gitignore-mode)
      (use-package git-commit
        :init
        (setq git-commit-summary-max-length 79))

      ;; Move back and forth between commits <3
      (use-package git-timemachine)

      ;; List and edit gists on github.com <3
      (use-package gist)
    #+end_src

*** magit

    ~magit~ is by far the best git interface ever conceived.
    This setup makes sure that the magit buffers are spawned fullscreen and
    that the previous screen layout is restored when it is buried.

    #+begin_src emacs-lisp
      (use-package magit
        :bind (("C-x g" . th/magit-status)
               :map magit-status-mode-map
               ("q"   . magit-mode-bury-buffer)
               ;; In certain modes we want to just kill the window, not magit entirely
               :map magit-process-mode-map
               ("q"   . delete-window))

        :init
        (defun th/magit-status ()
          (interactive)
          (save-some-buffers t)
          (magit-status))

        (setq magit-save-some-buffers 'dontask)
        (setq magit-last-seen-setup-instructions "1.4.0")

        (defadvice magit-status (around magit-fullscreen activate)
          (window-configuration-to-register :magit-fullscreen)
          ad-do-it
          (delete-other-windows))

        (defadvice magit-mode-bury-buffer (after magit-restore-screen activate)
          "Restores the previous window configuration and kills the magit buffer"
          (jump-to-register :magit-fullscreen)))

      (use-package magithub
        :after magit
        :config (magithub-feature-autoinject t))
    #+end_src

*** git-gutter

    Shows git status in the gutter of the file you are editing.

    #+begin_src emacs-lisp
      (use-package git-gutter+)

      (add-hook 'prog-mode-hook 'git-gutter+-mode)
    #+end_src

*** git hydra

    #+begin_src emacs-lisp
      (defhydra th/git-hydra ()
        "git"
        ("n" git-gutter+-next-hunk "next")
        ("p" git-gutter+-previous-hunk "prev")
        ("s" git-gutter+-stage-hunks "stage")
        ("r" git-gutter+-revert-hunk "revert")
        ("g" magit-status "magit" :exit t)
        ("b" magit-blame "blame" :exit t)
        ("l" magit-log-buffer-file "log" :exit t)
        ("t" git-timemachine "timemachine" :exit t)
        ("s" th/smerge-hydra/body "smerge" :exit t)
        ("RET" magithub-browse "repo" :exit t)
        ("SPC" git-gutter+-show-hunk-inline-at-point "show")
        ("q" nil))

      (global-set-key (kbd "C-x C-g") 'th/git-hydra/body)
    #+end_src

*** smerge hydra

    #+begin_src emacs-lisp
      (defhydra th/smerge-hydra (:foreign-keys warn)
        "smerge"
        ("n" smerge-next "next")
        ("p" smerge-prev "prev")
        ("a" smerge-keep-all "all")
        ("c" smerge-keep-current "current")
        ("RET" smerge-keep-current "current")
        ("o" smerge-keep-other "other")
        ("DEL" smerge-keep-other "other")
        ("m" smerge-keep-mine "mine")
        ("SPC" smerge-keep-mine "mine")
        ("b" smerge-keep-base "base")
        ("q" smerge-mode :exit t))

      ;; (add-hook 'smerge-mode-hook 'th/smerge-hydra/body)
    #+end_src

** Utility hydra

   This is a hydra that does many things that are useful every now and
   again. It can:

   * Toggle ~auto-fill~, ~fci~, ~linum~, ~highlight-symbol~,
     ~rainbow-identifiers~, and ~truncate-lines~ modes.
   * Increase and decrease font size for the current buffer
   * Open a font size hydra
   * Load .env files in a repository into the emacs env
   * Enter the yas hydra

   #+begin_src emacs-lisp
     (defhydra th/util-hydra (:foreign-keys warn)
       "Util"
       ("e" th/load-env "Load 12FA env" :color blue)
       ("s" th/yas-hydra/body "yas" :color blue)
       ("a" auto-fill-mode "Auto fill")
       ("f" th/font-hydra/body "font-hydra" :color blue)
       ("M-f" fci-mode "Fill column")
       ("h" highlight-symbol-mode "Highlight symbol")
       ("j" text-scale-decrease "Font -")
       ("k" text-scale-increase "Font +")
       ("l" linum-mode "Line numbers")
       ("r" rainbow-identifiers-mode "Rainbow identifiers")
       ("t" toggle-truncate-lines "Truncate lines"))

     (global-set-key (kbd "C-x c") 'th/util-hydra/body)
   #+end_src

   Also the font size hydra

   #+begin_src emacs-lisp
     (defun th/iosevka (size)
       (set-frame-font (format "Iosevka-%s" size)))

     (defhydra th/font-hydra ()
       "Font size"
       ("d" (th/iosevka 10))
       ("f" (th/iosevka 13))
       ("h" (th/iosevka 17))
       ("j" (th/iosevka 20))
       ("k" (th/iosevka 22))
       ("l" (th/iosevka 24))
       ("i" (describe-char (point)) "font information" :color blue))
   #+end_src

** Execution hydra

   Hydra that starts things

   #+begin_src emacs-lisp
     (defhydra th/exec-hydra (:foreign-keys warn :exit t)
       "Execution"
       ("e" elfeed "elfeed")
       ("h" (counsel-find-file "/") "hosts")
       ("p" payments/actions/body "payments")
       ("M-p" proced "proced")
       ("q" nil))

     (global-set-key (kbd "C-x C-c") 'th/exec-hydra/body)
   #+end_src

** move-text

   Moving lines up and down. Also tries to indent according to where it lands

   #+begin_src emacs-lisp
     (defun move-line-up ()
       (interactive)
       (transpose-lines 1)
       (forward-line -2)
       (indent-for-tab-command))

     (defun move-line-down ()
       (interactive)
       (forward-line 1)
       (transpose-lines 1)
       (forward-line -1)
       (indent-for-tab-command))

     (global-set-key [M-up] 'move-line-up)
     (global-set-key [M-down] 'move-line-down)
   #+end_src

** multiple-cursors

   Quickfast editing of multiple places at once.

   #+begin_src emacs-lisp
     (use-package multiple-cursors
       :bind
       ("C-x C-l" . mc/mark-next-like-this)
       ("C-x C-h" . mc/mark-previous-like-this)
       ("C-M-s"   . mc/edit-lines))
   #+end_src

** password-store

   Emacs interface to [[https://www.passwordstore.org][pass]]. <3

   #+begin_src emacs-lisp
     (use-package pass)
   #+end_src

** prettify-symbols

   Because it's more fun to have a pretty lambda!

   #+begin_src emacs-lisp
     (global-prettify-symbols-mode 0)
   #+end_src

** Rainbows <3

   The rainbow modes bring nice colors to your code:

   * =rainbow-mode= colorizes strings like ~red~ and ~#405060~.
   * =rainbow-delimiters= colorizes parenthesis, brackets and other delimiters.
   * =rainbow-identifiers= colorizes variables in different colors.

   #+begin_src emacs-lisp
     (use-package rainbow-mode)
     (use-package rainbow-delimiters)
     (use-package rainbow-identifiers)
   #+end_src

** Rotate text

   #+begin_src emacs-lisp
     (use-package rotate-text
       :init
       (setq rotate-text-words '(("width" "height")
                                 ("left" "right" "top" "bottom")
                                 ("true" "false")
                                 ("==" "!=" "<=" ">=")))

       (setq rotate-text-symbols '(("true" "false")
                                   ("==" "!=" "<=" ">=")))
       :bind (("M-r" . rotate-text)))
   #+end_src

** sqlup

   Uppercase SQL keywords as you type them <3

   #+begin_src emacs-lisp
     (use-package sqlup-mode
       :config
       (add-hook 'sql-mode-hook 'sqlup-mode))
   #+end_src

** visual-regexp-steroids

   Nice little mode to get a better search/replace experience.

   #+begin_src emacs-lisp
     (use-package visual-regexp-steroids
       :bind
       ("C-r" . vr/replace))
   #+end_src

* Setup and options
** Aborting and stopping

   Every once in a blue moon, you actually want out of emacs...

   #+begin_src emacs-lisp
     ;; The default isn't that great actually.
     (global-unset-key (kbd "C-x C-c"))

     ;; Hard to accidentally do, but still easy to hit.
     (global-set-key (kbd "<f11>") 'save-buffers-kill-emacs)
   #+end_src

** Autosave and backups

   Backups are disabled. Never had use for them, and the default settings are
   pretty littering.

   #+begin_src emacs-lisp
     (defvar --backup-directory (concat user-emacs-directory "backups"))

     (if (not (file-exists-p --backup-directory))
         (make-directory --backup-directory t))

     (setq backup-directory-alist `(("." . ,--backup-directory)))

     (setq make-backup-files nil      ; backup of a file the first time it is saved.
           backup-by-copying t        ; don't clobber symlinks
           version-control nil        ; version numbers for backup files
           delete-old-versions t      ; delete excess backup files silently
           delete-by-moving-to-trash nil
           create-lockfiles nil       ;
           kept-old-versions 1        ; oldest versions to keep when a new numbered backup is made (default: 2)
           kept-new-versions 1        ; newest versions to keep when a new numbered backup is made (default: 2)
           auto-save-default nil      ; auto-save every buffer that visits a file
           auto-save-timeout 9000     ; number of seconds idle time before auto-save (default: 30)
           auto-save-interval 900000  ; number of keystrokes between auto-saves (default: 300)
           )

     (setq global-auto-revert-non-file-buffers t)
     (setq auto-revert-verbose nil)

     (setq backup-inhibited t
           make-backup-files nil)

     ;; Save all tempfiles in $TMPDIR/emacs-$UID/
     (defconst emacs-tmp-dir
       (format "/tmp/emacs-%s/" (user-uid)))
     (make-directory emacs-tmp-dir t)

     (setq temporary-file-directory emacs-tmp-dir)
     (setq auto-save-list-file-prefix emacs-tmp-dir)
   #+end_src

** Browser setup

   This uses the `chrome-app` command from the dotfiles repo and puts browser
   configuration outside of emacs.

   #+begin_src emacs-lisp
     (setq browse-url-browser-function 'browse-url-generic
           browse-url-generic-program "chrome-app")
   #+end_src

** Clean mode line

   This tries to clean up the modeline as much as possible. I'm honestly not
   sure if it is still needed, but hey.

   Nicely borrowed from a [[http://www.masteringemacs.org/articles/2012/09/10/hiding-replacing-modeline-strings/][Mastering Emacs]] blog post.

   #+begin_src emacs-lisp
     (defvar mode-line-cleaner-alist
       `((paredit-mode . "")
         (lispy-mode . "()")
         (eldoc-mode . "")
         (abbrev-mode . "")
         (auto-fill-mode "")
         (magit-auto-revert-mode "")
         (auto-revert-mode "")
         (yas-minor-mode "")
         (undo-tree-mode "")
         (ivy-mode "")
         (editorconfig-mode "")
         (hungry-delete-mode "")

         ;; Major modes
         (js2-mode "js2")
         (javascript-mode "js")
         (help-mode . "")
         (fundamental-mode . "0")
         (python-mode . "py")
         (emacs-lisp-mode . "el")))

     (defun clean-mode-line ()
       (interactive)
       (cl-loop for cleaner in mode-line-cleaner-alist
                do (let* ((mode (car cleaner))
                          (mode-str (cdr cleaner))
                          (old-mode-str (cdr (assq mode minor-mode-alist))))
                     (when old-mode-str
                       (setcar old-mode-str mode-str))
                     ;; major mode
                     (when (eq mode major-mode)
                       (setq mode-name mode-str)))))

     (add-hook 'after-change-major-mode-hook 'clean-mode-line)
   #+end_src

** eshell

   eshell is nice and I am getting into the habit of using it! This defines a
   nice function that lets you drop into a shell in the directory where the
   current buffer is visiting a file.

   #+begin_src emacs-lisp
     (defun eshell-here ()
       "Opens up a new shell in the directory associated with the
     current buffer's file. The eshell is renamed to match that
     directory to make multiple eshell windows easier."
       (interactive)
       (let* ((parent (if (buffer-file-name)
                          (file-name-directory (buffer-file-name))
                        default-directory))
              (name (car (last (split-string parent "/" t))))
              (shellname (concat "*eshell: " name "*")))

         (if (not (get-buffer shellname))
             ;;
             (progn
               (eshell "new")
               (rename-buffer shellname))
           ;; If we're already in eshell, go back to where we were.
           ;; Otherwise, switch to it said eshell.
           (if (derived-mode-p 'eshell-mode)
               (previous-buffer)
             (switch-to-buffer shellname)))))

     (global-set-key (kbd "C-x e") 'eshell-here)

     (defun eshell/x ()
       (insert "exit")
       (eshell-send-input)
       (delete-window))

     (setenv "PAGER" "cat")
     (defalias 'e 'find-file)

     (defun th/eshell-menu ()
       "Go to one of the currently open eshell buffers (if there is one)."
       (interactive)
       (let* ((eshell-buffers (--map (buffer-name it)
                                    (--filter
                                     (equal 'eshell-mode (with-current-buffer it major-mode))
                                     (buffer-list)))))
         (if eshell-buffers
             (switch-to-buffer (completing-read "Select eshell: " eshell-buffers))
           (message "There's no eshell buffers open right now"))))

     (global-set-key (kbd "C-x M-e") 'th/eshell-menu)
   #+end_src

** Linum

   This sets up =linum=, but only for programming buffers. =org= gets super
   sad by line numbers for some reason.

   #+begin_src emacs-lisp
     (global-linum-mode 0)
     (setq linum-format " %4d ")
   #+end_src

** Minibuffer

   Pasting into the minibuffer. Inspired by a [[http://blog.binchen.org/posts/paste-string-from-clipboard-into-minibuffer-in-emacs.html][blog post]] found some time ago.

   #+begin_src emacs-lisp
     (defun th/paste-from-x-clipboard ()
       (interactive)
       (shell-command "echo $(xsel -o)" 1))

     (defun th/paste-in-minibuffer ()
       (local-set-key (kbd "M-y") 'th/paste-from-x-clipboard)
       (local-set-key [mouse-2] 'th/paste-from-x-clipboard))

     (add-hook 'minibuffer-setup-hook 'th/paste-in-minibuffer)
   #+end_src

** mode-line

   https://github.com/ocodo/.emacs.d/blob/master/custom/mode-line-hack.el

   #+begin_src emacs-lisp
     ;; Mode line setup - forked from http://amitp.blogspot.com.au/2011/08/emacs-custom-mode-line.html

     ;; Remove the silly "Git" part of the mode line. I know I'm using git.
     (setcdr (assq 'vc-mode mode-line-format)
             '((:eval (replace-regexp-in-string "^ Git." " " vc-mode))))

     (setq-default
      mode-line-format
      '("  "
        ; Position, including warning for 80 columns
        (:propertize "%4l:" face mode-line-position-face)
        (:eval (propertize "%3c" 'face
                           (if (>= (current-column) 100)
                               'mode-line-hi-col-face
                             'mode-line-position-face)))
        ; emacsclient [default -- keep?]
        mode-line-client
        "  "
        ; read-only or modified status
        (:eval
         (cond (buffer-read-only
                (propertize " RO " 'face 'mode-line-read-only-face))
               ((and (buffer-modified-p) (not (s-prefix? "*" (buffer-name))))
                (propertize " ** " 'face 'mode-line-modified-face))
               (t "    ")))
        "    "
        ; directory and buffer/file name
        (:propertize (:eval (when (and
                                   (not (s-contains? "*" (buffer-name)))
                                   (not (file-remote-p (buffer-file-name))))
                              (let* ((projectile-require-project-root nil)
                                     (ppr (projectile-project-root))
                                     (target default-directory))
                                ;; If there is a projectile root, remove everything
                                ;; in front of its name to save space.
                                (when ppr (setq
                                           target
                                           (s-replace (concat (f-dirname ppr) "/") "" target)))

                                (shorten-directory target 30))))
                     face mode-line-folder-face)
        (:propertize "%b"
                     face mode-line-filename-face)
        ; narrow [default -- keep?]
        " %n "
        ; mode indicators: vc, recursive edit, major mode, minor modes, process, global
        (vc-mode vc-mode)
        "  %["
        (:propertize mode-name
                     face mode-line-mode-face)
        "%] "
        (:eval (propertize (format-mode-line minor-mode-alist)
                           'face 'mode-line-minor-mode-face))
        (:propertize mode-line-process
                     face mode-line-process-face)
        (global-mode-string global-mode-string)
        "    "
        ; nyan-mode uses nyan cat as an alternative to %p
        (:eval (when nyan-mode (list (nyan-create))))))

     ;; Helper function
     (defun shorten-directory (dir max-length)
       "Show up to `max-length' characters of a directory name `dir'."
       (let ((path (reverse (split-string (abbreviate-file-name dir) "/")))
             (output ""))
         (when (and path (equal "" (car path)))
           (setq path (cdr path)))
         (while (and path (< (length output) (- max-length 4)))
           (setq output (concat (car path) "/" output))
           (setq path (cdr path)))
         (when path
           (setq output (concat ".../" output)))
         output))

     ;; Extra mode line faces
     (make-face 'mode-line-read-only-face)
     (make-face 'mode-line-modified-face)
     (make-face 'mode-line-folder-face)
     (make-face 'mode-line-filename-face)
     (make-face 'mode-line-position-face)
     (make-face 'mode-line-mode-face)
     (make-face 'mode-line-minor-mode-face)
     (make-face 'mode-line-process-face)
     (make-face 'mode-line-hi-col-face)

     (set-face-attribute 'mode-line nil          :foreground "gray80" :background "#333333" :inverse-video nil :box '(:line-width 1 :color "#101010" :style nil))
     (set-face-attribute 'mode-line-inactive nil :foreground "gray60" :background "#1d2021" :inverse-video nil :box '(:line-width 1 :color "#101010" :style nil))

     (set-face-attribute 'mode-line-read-only-face nil  :inherit 'mode-line-face          :foreground "#4271ae" :box '(:line-width 1 :color "#4271ae"))
     (set-face-attribute 'mode-line-modified-face nil   :inherit 'mode-line-face          :foreground "#FF0000" :background "#dbdbdb" :box '(:line-width 1 :color "#880000"))
     (set-face-attribute 'mode-line-folder-face nil     :inherit 'mode-line-face          :foreground "gray50")
     (set-face-attribute 'mode-line-filename-face nil   :inherit 'mode-line-face          :foreground "#FABD2F" :weight 'bold)
     (set-face-attribute 'mode-line-position-face nil   :inherit 'mode-line-face)
     (set-face-attribute 'mode-line-mode-face nil       :inherit 'mode-line-face          :foreground "#fe8019")
     (set-face-attribute 'mode-line-minor-mode-face nil :inherit 'mode-line-mode-face     :foreground "gray60")
     (set-face-attribute 'mode-line-process-face nil    :inherit 'mode-line-face          :foreground "#718c00")
     (set-face-attribute 'mode-line-hi-col-face nil     :inherit 'mode-line-position-face :foreground "black" :background "#db6000")
   #+end_src
** Narrowing

   http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html

   #+begin_src emacs-lisp
     (defun narrow-or-widen-dwim (p)
       "Widen if buffer is narrowed, narrow-dwim otherwise.
     Dwim means: region, org-src-block, org-subtree, or
     defun, whichever applies first. Narrowing to
     org-src-block actually calls `org-edit-src-code'.

     With prefix P, don't widen, just narrow even if buffer
     is already narrowed."
       (interactive "P")
       (declare (interactive-only))
       (cond ((and (buffer-narrowed-p) (not p)) (widen))
             ((region-active-p)
              (narrow-to-region (region-beginning)
                                (region-end)))
             ((derived-mode-p 'org-mode)
              ;; `org-edit-src-code' is not a real narrowing
              ;; command. Remove this first conditional if
              ;; you don't want it.
              (cond ((ignore-errors (org-edit-src-code) t)
                     (delete-other-windows))
                    ((ignore-errors (org-narrow-to-block) t))
                    (t (org-narrow-to-subtree))))
             (t (narrow-to-defun))))

     ;; This line actually replaces Emacs' entire narrowing
     ;; keymap, that's how much I like this command. Only
     ;; copy it if that's what you want.
     (define-key ctl-x-map "n" #'narrow-or-widen-dwim)
   #+end_src
** Options and settings
#+begin_src emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
  (setq-default indicate-empty-lines t)

  (fringe-mode 12)
  (setq scroll-step 10)

  (setq debug-on-error nil)

  (set-default 'truncate-lines nil)

  (setq mouse-yank-at-point t)

  (setq compilation-read-command nil)

  (setq inhibit-startup-screen t
        initial-scratch-message ";; *scratch*\n\n")

  (setq compilation-scroll-output t)

  (add-hook 'after-save-hook
    'executable-make-buffer-file-executable-if-script-p)

  (defadvice save-buffer (around save-buffer-as-root-around activate)
    "Create non-existing parent directories; sudo to save the current buffer if permissions are lacking."
    (interactive "p")

    ;; Only do any of this if we actually have a file
    (if (buffer-file-name)
        (progn
          ;; Create the parent directories
          (make-directory (f-dirname (buffer-file-name)) t)

          ;; If the file is not writeable, try
          (if (not (file-writable-p (buffer-file-name)))
              (let ((buffer-file-name (format "/sudo::%s" buffer-file-name)))
                ad-do-it))
          ad-do-it)
      ad-do-it))

  (setq echo-keystrokes 0.4
        standard-indent 4
        tab-always-indent 'complete)

  (setq-default comment-column 42
                fill-column 78
                indent-tabs-mode nil
                tab-width 2
                word-wrap t)

  (put 'downcase-region 'disabled nil)

  (show-paren-mode t)
  (electric-pair-mode t)
  (global-auto-revert-mode t)
  (auto-fill-mode t)
  (fci-mode 1)

  (setq enable-recursive-minibuffers t)
#+end_src
** uniquify

   emacs has this interesting habit of wanting to make new buffers every time
   you visit a new file. This is silly, and this plugin fixes that.

   #+begin_src emacs-lisp
     (require 'uniquify)
     (setq uniquify-buffer-name-style 'forward)
   #+end_src

** Window management

   Sets up quicker window management bindings.

*** Settings

    These things set in which directions windows split.

   #+begin_src emacs-lisp
     ;; Try to make emax split vertically when possible
     (setq split-height-threshold 100)
     (setq split-width-threshold 160)

     ;; So that (compile) and other commands re-use already open buffers in other
     ;; frames. Really useful when using dual monitors.
     (setq display-buffer-reuse-frames t)
   #+end_src

*** Correction of window splitting

    I never liked the way a split is made but not moved into.

    #+begin_src emacs-lisp
      (defun th/split-horizontally ()
        (interactive)
        (split-window-below)
        (windmove-down)
        (balance-windows))

      (defun th/split-vertically ()
        (interactive)
        (split-window-right)
        (windmove-right)
        (balance-windows))
    #+end_src

*** Autobalance

    #+begin_src emacs-lisp
      (defadvice split-window-sensibly (after split-window-sensibly-autobalance activate)
        (balance-windows))
    #+end_src
*** Killing windows

    I kill windows all the time. So often that I want to be able to do it
    super quickly. So, =C-q= comes into play!

    #+begin_src emacs-lisp
      (defun th/kill-window ()
        "Kill the window. If it's the last one in the frame and the server is running, kill the frame."
        (interactive)
        (if (and (one-window-p) (server-running-p))
            (progn
              (when (buffer-file-name)
                (save-buffer))
              (delete-frame))
          (progn
            (delete-window)
            (save-excursion
              (balance-windows)))))

      (global-set-key (kbd "C-q") 'th/kill-window)
    #+end_src

*** Hydra switching

    Hydras are great, especially for these kinds of things.
    http://oremacs.com/2015/02/04/pre-hydra-post/

    #+begin_src emacs-lisp
      (defhydra hydra-window ()
         "window"
         ("h" windmove-left)
         ("j" windmove-down)
         ("k" windmove-up)
         ("l" windmove-right)
         ("H" shrink-window-horizontally)
         ("J" shrink-window)
         ("K" enlarge-window)
         ("L" enlarge-window-horizontally)
         ("f" projectile-find-file "file" :color blue)
         ("p" projectile-switch-project "project" :color blue)
         ("b" balance-windows "balance")
         ("e" next-error "next error")
         ("E" previous-error "prev error")
         ("M-e" first-error "first error")
         ("n" new-frame "new frame" :color blue)
         ("a" (lambda ()
                (interactive)
                (ace-window 1)
                (add-hook 'ace-window-end-once-hook
                          'hydra-window/body)
                (throw 'hydra-disable t))
          "ace")
         ("s" th/split-vertically "vert")
         ("z" th/split-horizontally "horz")
         ("w" (lambda ()
                (interactive)
                (ace-window 4)
                (add-hook 'ace-window-end-once-hook
                          'hydra-window/body)
                (throw 'hydra-disable t))
          "swap")
         ("t" transpose-frame "'")
         ("d" (lambda ()
                (interactive)
                (ace-window 16)
                (add-hook 'ace-window-end-once-hook
                          'hydra-window/body)
                (balance-windows)
                (throw 'hydra-disable t))
          "del")
         ("o" delete-other-windows "one" :color blue)
         ("i" ace-maximize-window "ace-one" :color blue)
         ("q" nil "cancel"))

      (defun th/copy-or-hydra-window ()
        "M-w without a region is terrible. Make it useful instead."
        (interactive)
        (if (use-region-p)
            (kill-ring-save (region-beginning) (region-end))
          (hydra-window/body)))

      (global-set-key (kbd "M-w") 'th/copy-or-hydra-window)

   #+end_src

*** Quick switching

    Even though the hydra above is great, there are some things we just do all
    the time - and those need better binds.

    #+begin_src emacs-lisp
      (global-set-key (kbd "C-x h") 'windmove-left)
      (global-set-key (kbd "C-x j") 'windmove-down)
      (global-set-key (kbd "C-x k") 'windmove-up)
      (global-set-key (kbd "C-x l") 'windmove-right)

      ;; Also disable the old ones so that I stop using them
      (defun th/disabled-key ()
        (interactive)
        (message "This key is disabled. Use M-w."))

      (global-set-key (kbd "C-x 1") 'th/disabled-key)
      (global-set-key (kbd "C-x 2") 'th/disabled-key)
      (global-set-key (kbd "C-x 3") 'th/disabled-key)

      (global-set-key (kbd "M-1") 'delete-other-windows)
      (global-set-key (kbd "M-2") 'th/split-horizontally)
      (global-set-key (kbd "M-3") 'th/split-vertically)


    #+end_src

* Work

  Work-specific things that are in other repositories because secrets.

  #+begin_src emacs-lisp
    (require 'f)
    (let ((work-path "~/spotify/elisp/"))
      (when (f-dir? work-path)
        (add-to-list 'load-path work-path)
        (require 'payments)))
  #+end_src

* Theme fixes

  Because of how emacs loads things, some of the fixes need to be applied
  really late. Like, linum has not been loaded when the theme loading
  happens. As such, we place it here.

  #+begin_src emacs-lisp
    (th/fix-darktooth)
  #+end_src

If only I was not one of those so very fond of tinkering and dotfiling, I
might've actually gotten things done. That would have been something, right?
