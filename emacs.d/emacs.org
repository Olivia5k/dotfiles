#+TITLE: init file for Emacs
#+AUTHOR: Lowe Thiderman
#+EMAIL: lowe.thiderman@gmail.com

* Introduction

This is my emax setup. It's a constant work in progress. The current setup is
like this, as an [[https://orgmode.org][org-mode]] plain text file that compiles down to an elisp file
that is compiled upon startup. org-mode was chose since it helps organize the
file, gives nice folding, and sets up for writing inline documentation.

If only I was not one of those so very fond of tinkering and dotfiling, I
might've actually gotten things done. That would have been something, right?

* Common Lisp
#+begin_src emacs-lisp
(require 'cl)
#+end_src
* Package configuration
** Path configuration
#+begin_src emacs-lisp
  (add-to-list 'load-path (concat user-emacs-directory "lisp"))

  (setq custom-theme-directory (concat user-emacs-directory "themes"))

  (dolist
      (path (directory-files custom-theme-directory t "\\w+"))
    (when (file-directory-p path)
      (add-to-list 'custom-theme-load-path path)))
#+end_src
** Preamble and setup

Sets up the repositories to get packages from. Extra and more frequently
updated repositories outside of MELPA are added. Order matters.

#+begin_src emacs-lisp
  (require 'package)
  (add-to-list 'package-archives
               '("melpa" . "http://melpa.org/packages/") t)
  (package-initialize)

  (eval-after-load "package"
    '(progn
       (add-to-list 'package-archives '("tromey" . "http://tromey.com/elpa/"))
       (add-to-list 'package-archives '("marmalade" . "http://marmalade-repo.org/packages/"))
       (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))
       (add-to-list 'package-archives '("melpa" . "http://melpa.milkbox.net/packages/"))))

  ;; required because of a package.el bug
  ;(setq url-http-attempt-keepalives nil)
#+end_src
** Packages

Defines the packages to be installed.

#+begin_src emacs-lisp
  (defvar elpa-packages
    '(
      ace-jump-mode
      adaptive-wrap
      anaconda-mode
      avy
      browse-kill-ring
      buffer-move
      cl-lib
      company
      company-go
      crontab-mode
      csv-mode
      dash
      diminish
      discover-my-major
      dockerfile-mode
      emmet
      epl
      expand-region
      f
      fill-column-indicator
      flycheck
      fringe-helper
      gist
      git-commit-mode
      git-messenger
      git-timemachine
      gitconfig-mode
      gitignore-mode
      go-mode
      go-eldoc
      helm
      helm-ag
      helm-c-yasnippet
      helm-dash
      helm-descbinds
      helm-projectile
      helm-swoop
      htmlize
      httpcode
      ioccur
      js2-mode
      lispy
      magit
      magit-gh-pulls
      markdown-mode
      melpa
      multiple-cursors
      nginx-mode
      org-bullets
      org-fstree
      org-jekyll
      paradox
      paredit
      pkg-info
      popwin
      projectile
      protobuf-mode
      puppet-mode
      rainbow-delimiters
      rainbow-identifiers
      rainbow-mode
      rich-minority
      s
      skewer-mode
      spaceline
      ssh-config-mode
      string-inflection
      transpose-frame
      undo-tree
      virtualenvwrapper
      visual-regexp-steroids
      wrap-region
      xkcd
      yaml-mode
      yasnippet
      zenburn)
    "A list of packages to be installed at launch.")
#+end_src
** Actual package installation
#+begin_src emacs-lisp
  (when (not package-archive-contents)
    (package-refresh-contents))

  (dolist (pkg elpa-packages)
    (when (and (not (package-installed-p pkg))
             (assoc pkg package-archive-contents))
      (package-install pkg)))
#+end_src
** Required packages for the configuration
#+begin_src emacs-lisp
  (require 's)
#+end_src
* Interface
** Appearance
#+begin_src emacs-lisp
  (set-default-font "Inconsolata-12")
  (load-theme darktooth t)

  ;; Remove underlines, make everything bold.
  (mapc
   (lambda (face)
     (set-face-attribute face nil ':bold t :underline nil))
   (face-list))
#+end_src
** Helm

[[http://tuhdo.github.io/helm-intro.html][helm]] is a fuzzy interface builder that can be used with almost any part of emacs.
It replaces ido, flex etc.

It should be noted that the default fuzzy finding is slightly different from
what you are probably used to. There are no implicit ".*" between all
characters. You either add an explicit ".* " or (more commonly) you add a
space. Adding a space will add a new filter to your already filtered matches,

and it can be done multiple times.
It seems difficult in the beginning, but once you get used to it the feature
becomes natural and very powerful.

*** Include helm
#+begin_src emacs-lisp
  (require 'helm)
  (require 'helm-config)

  (helm-mode 1)
#+end_src
*** Keybindings
#+begin_src emacs-lisp
  ;; Main access
  (global-set-key (kbd "M-x") 'helm-M-x)
  (global-set-key (kbd "C-x b") 'helm-mini)

  (defun switch-to-previous-buffer ()
    "Switch to previously open buffer.
  Repeated invocations toggle between the two most recently open buffers."
    (interactive)
    (switch-to-buffer (other-buffer (current-buffer) 1)))
  (global-set-key (kbd "C-x C-b") 'switch-to-previous-buffer)

  (global-set-key (kbd "C-x f") 'helm-projectile)

  (global-set-key (kbd "C-c h") 'helm-command-prefix)
  (global-set-key (kbd "M-i") 'helm-semantic-or-imenu)

  ;; The default binding is... pretty bad.
  (global-unset-key (kbd "C-x c"))

  (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebind tab to run persistent action
  (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action) ; make TAB works in terminal
  (define-key helm-map (kbd "C-z") 'helm-select-action) ; list actions using C-z

#+end_src
*** Settings
#+begin_src emacs-lisp
  (when (executable-find "curl")
    (setq helm-google-suggest-use-curl-p t))

  (setq helm-split-window-in-side-p           t ; open helm buffer inside current window, not occupy whole other window
        helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
        helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
        helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
        helm-ff-file-name-history-use-recentf t)

  ;; https://www.reddit.com/r/emacs/comments/2z7nbv/lean_helm_window/
  (helm-autoresize-mode 1)
  (setq helm-autoresize-max-height 30)
  (setq helm-autoresize-min-height 30)
#+end_src
*** helm-swoop

[[https://github.com/ShingoFukuyama/helm-swoop][helm-swoop]] is an extension concerning searching, filtering and replacing text
inside of a single or multiple buffers.

One nice trick is to use helm-swoop to replace multiple occurances easily;
Do a swoop, filter to the lines you want to change, and then to C-c C-e for
edit mode. Once in there, do the usual (probably C-r) and then save that
buffer. Boom!

#+begin_src emacs-lisp
  (require 'helm-swoop)

  (global-set-key (kbd "C-s") 'helm-swoop)
  (global-set-key (kbd "C-c M-i") 'helm-multi-swoop)
  (global-set-key (kbd "C-x M-i") 'helm-multi-swoop-all)

  ;; From helm-swoop to helm-multi-swoop-all
  (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop)

  ;; Move up and down like isearch
  (define-key helm-swoop-map (kbd "C-r") 'helm-previous-line)
  (define-key helm-swoop-map (kbd "C-s") 'helm-next-line)
  (define-key helm-multi-swoop-map (kbd "C-r") 'helm-previous-line)
  (define-key helm-multi-swoop-map (kbd "C-s") 'helm-next-line)

  ;; Save buffer when helm-multi-swoop-edit complete
  (setq helm-multi-swoop-edit-save t)

  ;; If this value is t, split window inside the current window
  (setq helm-swoop-split-with-multiple-windows t)

  ;; Split direcion. 'split-window-vertically or 'split-window-horizontally
  (setq helm-swoop-split-direction 'split-window-vertically)

  ;; If nil, you can slightly boost invoke speed in exchange for text color
  (setq helm-swoop-speed-or-color t)

  ;; Go to the opposite side of line from the end or beginning of line
  (setq helm-swoop-move-to-line-cycle t)

  ;; Optional face for line numbers
  ;; Face name is `helm-swoop-line-number-face`
  (setq helm-swoop-use-line-number-face t)

  ;; Disable pre-input
  (setq helm-swoop-pre-input-function
        (lambda () ""))
#+end_src
*** helm-dash

[[https://github.com/areina/helm-dash][helm-dash]] is a helm-based interface to [[https://kapeli.com/dash][Dash]], the API documentation service.

#+begin_src emacs-lisp
  ;; helm-dash
  (require 'helm-dash)
  (setq helm-dash-browser-func 'eww)
#+end_src
*** helm-grep

Use helm to grep for files in the current project.

Uses ag if available, but falls back to grep if not.
Only available when projectile is active, e.g. when you are editing files
under git.

Note that C-j will preview the file without closing the helm buffer.

#+begin_src emacs-lisp
  (if (executable-find "ag")
      (global-set-key (kbd "C-M-s") 'helm-projectile-ag)
    (global-set-key (kbd "C-M-s") 'helm-projectile-grep))
#+end_src
** Projectile
#+begin_src emacs-lisp
  (require 'projectile)
  (projectile-global-mode)

  (setq projectile-completion-system 'helm)
  (setq projectile-mode-line nil)
#+end_src
** spaceline
#+begin_src emacs-lisp
  (require 'spaceline-config)
  (spaceline-spacemacs-theme)
#+end_src
** popwin
#+begin_src emacs-lisp
  (require 'popwin)
  (popwin-mode 1)

  (global-set-key (kbd "C-x p") popwin:keymap)
  (global-set-key (kbd "C-x C-k") 'popwin:close-popup-window)
#+end_src
* Editing
** undo tree
#+begin_src emacs-lisp
  (global-set-key (kbd "C-z") 'undo-tree-undo)
  (global-set-key (kbd "C-x C-z") 'undo-tree-undo)
  (global-set-key (kbd "C-M-z") 'undo-tree-redo)
  (global-undo-tree-mode +1)
#+end_src
** fill mode
#+begin_src emacs-lisp
  (auto-fill-mode 1)
  (set-fill-column 79)
#+end_src
** yas
#+begin_src emacs-lisp
  (require 'yasnippet)
  (require 'helm-c-yasnippet)

  ;; Without this, it doesn't load...
  (yas-reload-all)
  (setq helm-yas-space-match-any-greedy t) ;[default: nil]
  (global-set-key (kbd "C-c h s") 'helm-yas-complete)

  (add-hook 'prog-mode-hook 'yas-minor-mode)
  (add-hook 'markdown-mode 'yas-minor-mode)
  (add-hook 'org-mode-hook 'yas-minor-mode)
#+end_src
** Save hooks
#+begin_src emacs-lisp
  (add-hook 'before-save-hook
            (lambda ()
              (save-excursion
                (save-restriction
                  (delete-trailing-whitespace)
                  (widen)
                  (goto-char (point-max))
                  (delete-blank-lines)))))
#+end_src
** Commenting code
#+begin_src emacs-lisp
  (defun comment-eclipse ()
    (interactive)
    (let ((start (line-beginning-position))
          (end (line-end-position)))
      (when (region-active-p)
        (setq start (save-excursion
                      (goto-char (region-beginning))
                      (beginning-of-line)
                      (point))
              end (save-excursion
                    (goto-char (region-end))
                    (end-of-line)
                    (point))))
      (comment-or-uncomment-region start end)))

  (global-set-key (kbd "M-;") 'comment-eclipse)
#+end_src
** Autocompletion
#+begin_src emacs-lisp
  (require 'company)
  (require 'company-go)

  (setq company-tooltip-limit 20)                      ; bigger popup window
  (setq company-idle-delay .3)                         ; decrease delay before autocompletion popup shows
  (setq company-echo-delay 0)                          ; remove annoying blinking
  (setq company-begin-commands '(self-insert-command)) ; start autocompletion only after typing
#+end_src
** Line duplication
#+begin_src emacs-lisp
  (defun duplicate-current-line-or-region (arg)
    "Duplicates the current line or region ARG times.
     If there's no region, the current line will be duplicated. However, if
     there's a region, all lines that region covers will be duplicated."
    (interactive "p")
    (let (beg end (origin (point)))
      (if (and mark-active (> (point) (mark)))
          (exchange-point-and-mark))
      (setq beg (line-beginning-position))
      (if mark-active
          (exchange-point-and-mark))
      (setq end (line-end-position))
      (let ((region (buffer-substring-no-properties beg end)))
        (dotimes (i arg)
          (goto-char end)
          (newline)
          (insert region)
          (setq end (point)))
        (goto-char (+ origin (* (length region) arg) arg)))))

  (global-set-key (kbd "C-x d") 'duplicate-current-line-or-region) ; fak u paredit <3
#+end_src
** Entire line operation
#+begin_src emacs-lisp
  (global-set-key (kbd "M-k")
                  (lambda ()
                    (interactive)
                    (beginning-of-line)
                    (if (eq (point) (point-max))
                        (previous-line))
                    (kill-line 1)
                    (back-to-indentation)))

  (defun yank-entire-line ()
    (interactive)
    (save-excursion
      (beginning-of-line)
      (set-mark-command)
      (end-of-line)
      (kill-ring-save)))
#+end_src
** Default keys
#+begin_src emacs-lisp
  (global-set-key (kbd "M-g") 'helm-swoop)
  (global-set-key (kbd "C-r") 'vr/replace)
  (global-set-key (kbd "M-j")
                  (lambda ()
                    (interactive)
                    (join-line -1)))
#+end_src
** Enhanced default keybindings
*** C-a
#+begin_src emacs-lisp
  (defun back-to-indentation-or-previous-line ()
    "Go to first non whitespace character on a line, or if already on the first
    non whitespace character, go to the beginning of the previous non-blank line."
    (interactive)
    (if (= (point) (save-excursion (back-to-indentation) (point)))
        (previous-line))
    (if (and (eolp) (bolp))
        (back-to-indentation-or-previous-line))
    (back-to-indentation))

  (global-set-key (kbd "C-a") 'back-to-indentation-or-previous-line)
#+end_src
*** C-e
#+begin_src emacs-lisp
  (defun move-end-of-line-or-next-line ()
    (interactive)
    (if (eolp)
        (progn
          (next-line)
          (if (bolp)
              (move-end-of-line-or-next-line))))
    (move-end-of-line nil))

  (global-set-key (kbd "C-e") 'move-end-of-line-or-next-line)
#+end_src
*** C-o and C-M-o
#+begin_src emacs-lisp
  (defun insertline-and-move-to-line (&optional up)
    "Insert a newline, either below or above depending on `up`. Indent accordingly."
    (interactive)
    (beginning-of-line)
    (if up
        (progn
          (newline)
          (forward-line -1))
      (move-end-of-line nil)
      (open-line 1)
      (forward-line 1))
    (indent-according-to-mode))

  (global-set-key (kbd "C-o") 'insertline-and-move-to-line)
  (global-set-key (kbd "C-M-o") (lambda ()
                                  (interactive)
                                  (insertline-and-move-to-line t)))
#+end_src
*** M-F
#+begin_src emacs-lisp
  (defun forward-word-to-beginning (&optional n)
    "Move point forward n words and place cursor at the beginning."
    (interactive "p")
    (let (myword)
      (setq myword
            (if (and transient-mark-mode mark-active)
                (buffer-substring-no-properties (region-beginning) (region-end))
              (thing-at-point 'symbol)))
      (if (not (eq myword nil))
          (forward-word n))
      (forward-word n)
      (backward-word n)))

  (global-set-key (kbd "M-f") 'forward-word-to-beginning)
#+end_src
** Adding current buffer to minibuffer
#+begin_src emacs-lisp
  (define-key minibuffer-local-map [f3]
    (lambda () (interactive)
      (insert (file-truename (buffer-name
                              (window-buffer (minibuffer-selected-window)))))))

#+end_src
** Bubble lines
#+begin_src emacs-lisp
  (defun th-bubble-up ()
    "Moves current line to the line above"
    (interactive)
    (transpose-lines 1)
    (forward-line -2))

  (defun th-bubble-down ()
    "Moves current line to the line below"
    (interactive)
    (forward-line 1)
    (transpose-lines 1)
    (forward-line -1))

  (global-set-key (kbd "ESC <up>") 'th-bubble-up)
  (global-set-key (kbd "ESC <down>") 'th-bubble-down)
#+end_src
* Major modes
** org
*** Main setup
#+begin_src emacs-lisp
  (require 'org)

  (eval-after-load "org"
    '(progn
       (require 'org-clock)
       (require 'org-fstree)))

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)))

  (org-bullets-mode 1)

  (setq org-confirm-babel-evaluate nil)
  (setq org-directory "~/org")
  (setq org-fontify-emphasized-text t) ;; fontify *bold* _underline_ /italic/ and so on
  (setq org-return-follows-link t)
  (setq org-special-ctrl-a/e t)
  (setq org-special-ctrl-k t)
  (setq org-src-fontify-natively t)
  (setq org-src-tab-acts-natively t)
  (setq org-src-window-setup 'current-window)

  ; When calculating percentages of checkboxes, count all boxes, not just
  ; direct children
  (setq org-hierarchical-checkbox-statistics t)

  (define-key org-mode-map (kbd "M-i") 'helm-org-headlines)
  (define-key org-mode-map (kbd "C-c ;") 'org-edit-special)
  (define-key org-src-mode-map (kbd "C-c ;") 'org-edit-src-exit)
#+end_src
*** Agenda and todo
**** Settings and options
#+begin_src emacs-lisp
  (global-set-key (kbd "C-c a") 'org-agenda)

  (setq org-agenda-ndays 7)
  (setq org-agenda-files '("~/org/"))
  (setq org-agenda-show-all-dates t)
  (setq org-agenda-start-on-weekday nil)
  (setq org-archive-location "~/org/archive/%s::")
  (setq org-log-done t) ;;timestamp when switching from todo to done

  (setq org-todo-keywords '("TODO(t)" "WORKING(w)" "WAITING(z)" "REVIEW(r)" "|" "DONE(d)" "INVALID(i)"))
  (setq org-todo-keyword-faces '(("WORKING" . org-scheduled-today)
                                 ("WAITING" . org-mode-line-clock)))

#+end_src
**** Toggler keybindings
#+begin_src emacs-lisp
  (define-key org-mode-map (kbd "C-c t")
    (lambda ()
      (interactive)
      (org-todo "TODO")))

  (define-key org-mode-map (kbd "C-c w")
    (lambda ()
      (interactive)
      (org-todo "WORKING")))

  (define-key org-mode-map (kbd "C-c z")
    (lambda ()
      (interactive)
      (org-todo "WAITING")))

  (define-key org-mode-map (kbd "C-c r")
    (lambda ()
      (interactive)
      (org-todo "REVIEW")))

  (define-key org-mode-map (kbd "C-c d")
    (lambda ()
      (interactive)
      (org-todo "DONE")))

  (define-key org-mode-map (kbd "C-c i")
    (lambda ()
      (interactive)
      (org-todo "INVALID")))

  (define-key org-mode-map (kbd "C-c SPC")
    (lambda ()
      (interactive)
      (org-todo 'none)))

#+end_src
**** helm-org-agenda
#+begin_src emacs-lisp
  (defun th-helm-org-agenda-files ()
    (mapcar (lambda (s) (s-chop-suffix ".org" s))
            (directory-files "~/org/" nil ".*\\.org")))

  (defun th-helm-org-agenda-visit (file)
    (find-file (format "~/org/%s.org" file)))

  (defvar th-helm-org-agenda-sources
    '((name . "org-agenda files")
      (candidates . th-helm-org-agenda-files)
      (action . th-helm-org-agenda-visit)))

  (defun th-helm-org-agenda ()
    (interactive)
    (helm
     :sources th-helm-org-agenda-sources
     :prompt "Agenda file: "
     :buffer "*helm-org-agenda*"))

  (global-set-key (kbd "C-x C-o") 'th-helm-org-agenda)
#+end_src
**** org-goto-for-project
#+begin_src emacs-lisp
  (defun th-org-project ()
    "Go to the org project for the current repository.

  Go back if we're already in it."

    (interactive)
    (let* ((root (projectile-project-root))
           (name (car (last (s-split "/" (projectile-project-root)) 2))))
      (if (s-equals? (expand-file-name "~/org/") root)
          (progn
            (save-buffer)
            (previous-buffer))
        (find-file
         (format "~/org/%s.org" name)))))

  (global-set-key (kbd "C-x C-o") 'th-org-project)
#+end_src
**** Archiving
#+begin_src emacs-lisp
  (defun org-archive-done-tasks ()
    (interactive)
    (org-map-entries
     (lambda ()
       (org-archive-subtree)
       (setq org-map-continue-from (outline-previous-heading)))
     "/DONE" 'file))

  (define-key org-mode-map (kbd "C-c C-x C-a") 'org-archive-done-tasks)
#+end_src
** Elisp
#+begin_src emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
  (add-hook 'emacs-lisp-mode-hook 'lispy-mode)
  (add-hook 'emacs-lisp-mode-hook 'paredit-mode)
  (add-hook 'emacs-lisp-mode-hook 'rainbow-identifiers-mode)

  ;; pls no .elc
  (add-hook 'emacs-lisp-mode-hook
            (lambda ()
              (make-local-variable 'after-save-hook)
              (add-hook 'after-save-hook
                        (lambda ()
                          (if (file-exists-p (concat buffer-file-name "c"))
                              (delete-file (concat buffer-file-name "c")))))))

  (defun th-buffer-or-region (action-name buffer-func region-func)
    (let ((s "Buffer"))
      (if (use-region-p)
          (progn
            (funcall region-func (region-beginning) (region-end))
            (keyboard-escape-quit)
            (setq s "Region"))
        (funcall buffer-func))

      (message "buffer-or-region: %s %s" s action-name)))

  (defun eval-buffer-or-region ()
    (interactive)
    (th-buffer-or-region "eval" 'eval-buffer 'eval-region))

  (define-key emacs-lisp-mode-map (kbd "C-c C-e") 'eval-buffer-or-region)
#+end_src
** Python
#+begin_src emacs-lisp
  (require 'python)
  ;; (require 'snakecharmer)

  (add-hook 'python-mode-hook 'anaconda-mode)
  (add-hook 'python-mode-hook 'eldoc-mode)
  (add-hook 'python-mode-hook 'flycheck-mode)
  (define-key python-mode-map (kbd "C-c C-d") 'anaconda-mode-find-definitions)

  (defun th-python-mode-hook ()
    (add-to-list 'company-backends 'company-jedi))

  (add-hook 'python-mode-hook 'th-python-mode-hook)

  ;; (add-hook 'python-mode-hook
  ;;           (lambda ()
  ;;             (add-hook 'after-save-hook 'flycheck-first-error)))

  (defun sp-goto-mail ()
    "Go to the latest email in <root>/_outgoing_emails."
    (interactive)
    (find-file
     (car
      (last
       (directory-files
        (concat (projectile-project-root)
                "_outgoing_emails")
        t)))))



#+end_src
** golang

These are my Go tricks. They are fairly opinionated, but once they work well
enough I think I want to bring them to the upstream go-mode somehow!
[[https://github.com/dominikh/go-mode.el/pull/117][It started happening!]]

*** Ideas
**** TODO Compile in background
**** TODO Compile buffer recognition of tests
**** TODO Duplicate test function
**** TODO Toggle pointer to structs in file
**** TODO Toggle error as return value
**** TODO Template for error if nil (en)
**** TODO Replace inside function

#+begin_src emacs-lisp
  (require 'go-mode)
#+end_src

*** Main hook
#+begin_src emacs-lisp
  (defun th-go-hook ()
    (add-hook 'before-save-hook 'gofmt-before-save)
    (set (make-local-variable 'company-backends) '(company-go))
    (company-mode)
    (flycheck-mode 1)

    (helm-dash-activate-docset 'Go))

  (add-hook 'go-mode-hook 'th-go-hook)
  (add-hook 'go-mode-hook 'go-eldoc-setup)
#+end_src
*** goto functions
#+begin_src emacs-lisp
  ;; These were all moved into upstream! Yay open source <3
  (define-key go-mode-map (kbd "C-c g") 'go-goto-map)
#+end_src
*** Function browser
#+begin_src emacs-lisp
  (defun th-go-test-filter (files)
   (-filter (lambda (s) (s-contains? "_test.go" s)) files))

  (setq th-go-test-functions (make-hash-table :test 'equal))

  (gethash
   "/home/thiderman/var/go/src/github.com/thiderman/towerfall/tournament_test.go"
   th-go-test-functions)

  (defun th-go-test-files ()
    (-each (th-go-test-filter test-files)
      (lambda (fn)
        (puthash
         fn
         (th-go-filter-test-functions (th-go-get-functions-from-file fn))
         th-go-test-functions))))

  (defun th-go-get-functions-from-file (fn)
    "Filters out all functions from a file"
    (mapcar
     (lambda (s)
       (car (split-string (s-chop-prefix "func " s) "(" t)))
     (-filter
      (lambda (s)
        (s-prefix? "func" s))
      (with-temp-buffer
        (insert-file-contents fn)
        (split-string (buffer-string) "\n" t)))))


  (defun th-go-filter-test-functions (funcs)
    "Filters out all non-test functions from a list of functions"
    (-filter (lambda (s) (s-prefix? "Test" s)) funcs))

  (th-go-filter-test-functions (th-go-get-functions-from-file
    "/home/thiderman/var/go/src/github.com/thiderman/towerfall/tournament_test.go"))
#+end_src
*** Coverage functions
#+begin_src emacs-lisp
  (defun th-go-coverage ()
    "Toggle coverage mode for the current buffer"
    (interactive)

    (save-excursion
      (let ((bn (buffer-name)))
        (if (s-contains? "<gocov>" bn)
            (progn
              (windmove-left)
              (th-go-test-buffer-p))

          (if (s-contains? "_test.go" bn)
              (progn
                (windmove-left)
                (th-go-coverage-p))
            (windmove-right)
            (if (not (s-contains? "<gocov>" (buffer-name)))
                (progn
                  (windmove-left)
                  (th-go-coverage-p))
              (windmove-left)
              (th-go-test-buffer-p)))))))

  (defun th-go-coverage-p ()
    (delete-other-windows)
    (go-coverage (concat (projectile-project-root) "cover.out")))

  (define-key go-mode-map (kbd "C-c c") 'th-go-coverage)
#+end_src
*** Test file view
Brings up a split view of a single file and it's corresponding test file.
The test file will be created if it does not already exist.
#+begin_src emacs-lisp
  (defun th-go-test-buffer-p ()
    (let* ((bname (buffer-file-name))
           (left "")
           (right ""))

      (if (s-suffix? "_test.go" bname)
          (setq left (th-go-alternate-file bname)
                right bname)
        (setq left bname
              right (th-go-alternate-file bname)))

      (find-file left)
      (delete-other-windows)
      (split-window-horizontally)
      (windmove-right)
      (find-file right)))

  (defun th-go-test-buffer ()
    (interactive)
    (th-go-test-buffer-p))


  (defun th-go-test-buffer-split (file)
    ;; If we happen to be on the test file when splitting, go left once
    (when (th-go-test-file-p (buffer-file-name (get-buffer helm-current-buffer)))
      (windmove-left))

    (let ((fn (format "%s/%s.go" (projectile-project-root) file)))
      (split-window-below)
      (find-file fn)
      (windmove-right)
      (split-window-below)
      (find-file (th-go-alternate-file fn))
      (balance-windows)))


  (defun th-go-alternate-file (fn)
    "If fn is code, return path to test file and vice versa"

    (if (s-suffix? "_test.go" fn)
        (s-replace "_test.go" ".go" fn)
      (s-replace ".go" "_test.go" fn)))

  (defun th-go-test-file-p (&optional fn)
    "Returns boolean if the file name given is a test file"
    (s-contains? "_test.go"
                 (if (not fn)
                     (buffer-file-name)
                   fn)))

  (define-key go-mode-map (kbd "C-c a") 'th-go-test-buffer)
#+end_src
*** Single test execution
#+begin_src emacs-lisp
  (defun th-go-get-test-above ()
    "Gets the name of the test above point"
    (save-excursion
      (re-search-backward "^func \\(Test\\|Example\\)" nil t)
      (forward-word 2)
      (thing-at-point 'symbol t)))

  (defvar th-go-last-single-test "go test" "The last single test command that was run")

  (defun th-go-single-test ()
    "If in test file, run the test above point. If not, run the last run test."
    (interactive)
    (projectile-save-project-buffers)
    (when (th-go-test-file-p)
      (setq th-go-single-test (format "go test -v -run %s" (th-go-get-test-above))))
    (compile th-go-single-test))

  (define-key go-mode-map (kbd "C-M-x") 'th-go-single-test)
#+end_src
*** helm based file visitor
Shows a helm session with the current source files, and opens a view with the
chosen candidate and its corresponding test file.
#+begin_src emacs-lisp
  (defun th-helm-go-source-files ()
    (mapcar (lambda (s)
              (s-chop-suffix ".go" s))
            (-filter #'th-helm-go-filter-files
                     (directory-files (projectile-project-root) nil ".*\\.go"))))

  (defun th-helm-go-filter-files (x)
    (let ((fn (concat (projectile-project-root) x))
          (bufname (buffer-file-name (get-buffer helm-current-buffer))))
      (and
       (not (s-contains? "_test" x))      ; Test files
       (not (s-contains? ".#" x))         ; emax backups
       (not (s-contains? fn bufname))     ; the current module
       (not (s-contains? fn (th-go-alternate-file bufname)))))) ; and the current test module

  (defun th-helm-go-source-visit (file)
    (find-file (format "%s/%s.go" (projectile-project-root) file))
    (th-go-test-buffer-p))

  (defun th-helm-go-source-visit-split (file)
    (th-go-test-buffer-split file))

  (defvar th-helm-go-source-sources
    '((name . "go source files")
      (candidates . th-helm-go-source-files)
      (action . (
                 ("visit file" . th-helm-go-source-visit)
                 ("split below `C-c j'" . th-helm-go-source-visit-split)
                 ))))

  (defun th-helm-go-source ()
    (interactive)
    (helm
     :sources th-helm-go-source-sources
     :prompt "go source file: "
     :buffer "*helm-go-source*"))

  (define-key go-mode-map (kbd "C-c f") 'th-helm-go-source)
#+end_src
*** Snippet helpers
These are functions used inside of yas.
#+begin_src emacs-lisp
  (defun th-go-get-type-signature ()
    "Get the signature of the closest type: (t *Type)"
    (save-excursion
      (re-search-backward "^type" nil t)
      (if (looking-at "type")
          (progn (forward-word 2)
                 (let ((s (symbol-name (symbol-at-point))))
                   (format "(%s *%s)" (s-downcase (s-left 1 s)) s)))
        "")))

#+end_src
*** Compiling and executing
#+begin_src emacs-lisp
  (defun th-go-compile ()
    (interactive)
    (projectile-save-project-buffers)
    (compile
     "go generate && go test -coverprofile=cover.out && go build && go vet"))

  (define-key go-mode-map (kbd "C-c C-c") 'th-go-compile)
  (define-key go-mode-map (kbd "C-c C-k") 'popwin:close-popup-window)

  ;; NOTE: This is not go specific.
  (defun th-toggle-maximize-buffer (&optional buffer-name)
    "Maximize buffer"
    (interactive)
    (if (= 1 (length (window-list)))
        (jump-to-register '_)
      (progn
        (window-configuration-to-register '_)
        (if buffer-name
            (switch-to-buffer buffer-name))
        (delete-other-windows))))

  (defun th-quit-compilation-buffer ()
    ;; TODO: Maybe this can be done with advice instead?
    (interactive)
    (if (= 1 (length (window-list)))
        (jump-to-register '_)
      (quit-window)))

  (define-key compilation-mode-map (kbd "C-c l") 'th-toggle-maximize-buffer)
  (define-key compilation-mode-map (kbd "q") 'th-quit-compilation-buffer)

  (defun th-go-maximize-log ()
    (interactive)
    (th-toggle-maximize-buffer "*compilation*"))

  (define-key go-mode-map (kbd "C-c l") 'th-go-maximize-log)
#+end_src
*** Refactoring and renaming
#+begin_src emacs-lisp
  (define-key go-mode-map (kbd "C-c r") 'go-rename)
#+end_src
*** Docstring manipulation
#+begin_src emacs-lisp
  (defun th-go-update-docstring ()
    "Update the docstring of the current function to match the name it has."
    (interactive)
    (save-excursion
      ;; Since this will update if it is wrong, just call it and let it be.
      (th-go-goto-docstring)))

  (define-key go-mode-map (kbd "C-c M-d") 'th-go-update-docstring)
#+end_src
*** Struct pointer toggler
#+begin_src emacs-lisp
  (defun go--convert-type-name-to-receiver (tn)
    "Converts from the string \"Type\" to \"(t *Type)\""
    (format "(%s *%s)" (s-downcase (s-left 1 tn)) tn))

  (defun go--get-types (&optional file-name skip)
    "Return a list of all the types found in the current file.

  The strings returned are based on all lines that begin with
  '^type'. The letters 'type ' and the ending ' {' are both
  removed.

  If `skip' is provided, that type will not be included in the resulting list."
    (save-excursion
      (let ((fn (or file-name (buffer-file-name))))
        (-map
         (lambda (s) (s-chop-suffix " {" (s-chop-prefix "type " s)))
         (-filter
          (lambda (s)
            (if skip
                ;; If skip is provided, also filter out that line
                (and (s-prefix? "type " s)
                     (not (s-prefix? (format "type %s " skip) s)))
              ;; Otherwise just return lines that start with "type"
              (s-prefix? "type " s)))

          ;; Does emacs really don't have a cleaner way of getting lines in a
          ;; file? :/
          (with-temp-buffer
            (insert-file-contents fn)
            (split-string (buffer-string) "\n" t)))))))

  (defun go-refactor-method-receiver ()
    "Changes or removes the method receiver of the current function.

  A choice between all the types in the current file are
  interactively presented. Also presented is an item `<none>',
  which will remove the receiver if there is one.

  If there was a receiver and a new one is chosen,"
    ;; TODO(thiderman): We need to undo twice to undo this. Investigate.
    (interactive)
    (save-excursion
      (go-goto-function t)
      (forward-char 5)

      (let*
          ((empty "<none>")
           (current-var
            (save-excursion
              (forward-char 1)
              (thing-at-point 'symbol t)))
           (current-type
            (save-excursion
              (forward-char 1)
              (forward-word 2)
              (thing-at-point 'symbol t)))
           (type (completing-read
                  "Type: "
                  (append (go--get-types (buffer-file-name) current-type)
                          (list empty))))
           (receiver (when (not (s-equals? type empty))
                       (go--convert-type-name-to-receiver
                        (car (s-split " " type))))))

        (cond
         ;; If we are looking at an opening parenthesis, there is already a method receiver
         ((looking-at "(")
          ;; Firstly, store the current receiver variable name.


          ;; Then, delete the existing one.
          (delete-region
           (point)
           (save-excursion
             (forward-list 1)
             (point)))
          ;; If we do not have a receiver (i.e. we chose 'empty) we should
          ;; delete the extra space.
          (if (not receiver)
              (delete-char 1)
            ;; If there was a receiver previously and we set a new one, update the
            ;; variable name.
            (insert receiver)

            ;; And also update the variable name inside of the function.
            (when (and current-var receiver)
              (go--refactor-symbol-in-function
               current-var
               (s-downcase (s-left 1 type))))))
         ((and (not (looking-at "(")) receiver)
          ;; There is no receiver, but we are adding one. Just insert it.
          (insert (format "%s " receiver)))))))

  (defun go--refactor-symbol-in-function (from to)
    "Changes instances of the symbol `from' into `to'.

  Assumes that point is on line defining the function we are replacing in."
    (save-excursion
      (beginning-of-line)
      (let ((start
             (save-excursion
               (forward-line -1)
               (point)))
            (end
             (save-excursion
               ;; TODO(thiderman): Make a method that reliably moves to opening brace.
               (end-of-line)
               ;; In case of trailing whitespace...
               (search-backward "{")
               (forward-list 1)
               (backward-char 1)
               (point))))

        (replace-string from to t start end))))

  (define-prefix-command 'go-refactor-map)
  (define-key go-mode-map (kbd "C-c C-m") 'go-refactor-map)

  (define-key go-refactor-map (kbd "r") 'go-refactor-method-receiver)
#+end_src
*** General keybindings
#+begin_src emacs-lisp
  (define-key go-mode-map (kbd "C-c i") 'go-goto-imports)
  (define-key go-mode-map (kbd "C-c C-i") 'go-remove-unused-imports)
  (define-key go-mode-map (kbd "C-c d") 'godoc)
#+end_src
*** Debug toggler
#+begin_src emacs-lisp
  (defun go-toggle-debug ()
    "Toggle the toggle/debug file"
    (interactive)
    (let* ((dir (concat (projectile-project-root) "toggle/"))
           (toggle "debug")
           (action "Toggled")
           (fn (concat dir toggle)))
      ;; Create the directory if it doesn't already exist
      (when (not (f-directory? dir))
        (make-directory dir))

      ;; Toggle the existence of the file
      (if (f-file? fn)
          (progn
            (f-delete fn)
            (setq action "Disabled"))
        (with-temp-buffer
          (write-file fn))
        (setq action "Enabled"))
      (message "%s %s" action toggle)))

  (define-key go-mode-map (kbd "C-c M-d") 'go-toggle-debug)
#+end_src
** prog-mode
#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook 'semantic-mode)
  (add-hook 'prog-mode-hook (lambda ()
                              (auto-save-mode -1)))
#+end_src
** skewer
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))

  (add-hook 'js2-mode-hook 'skewer-mode)
  (add-hook 'css-mode-hook 'skewer-css-mode)
  (add-hook 'html-mode-hook 'skewer-html-mode)
#+end_src
* Minor modes and utilities
** Buffer toggles

F1: `helm-descbinds`
F2: Open this file
F3: Open main org file
F4: Scratch buffer
F5: Toggle debug mode
C-x ?: Print current file name relative to project root

*** Functions
#+begin_src emacs-lisp
  (defun th-toggle-buffer (func name &optional kill-window)
    "Toggle or destroy a buffer, depending on if it exists or not.

    The `func` argument should be a callable that toggles the buffer.
    The `name` argument is a substring of the buffer that should be matched."
    (interactive)
    (let ((done nil))
      (loop for buffer being the buffers
            do (let ((bname (buffer-name buffer)))
                 (when (s-contains? name bname)
                   (if kill-window
                       (progn
                         (select-window (get-buffer-window buffer))
                         (kill-buffer-and-window)
                         (message "Killed %s" bname))
                     (progn
                       (kill-buffer buffer)
                       (message "%s toggled away" bname)))
                   (setq done t))))
      (unless done
        (funcall func))))

  (defun th-toggle-file (path)
    (let ((file (file-truename path)))
      (if (s-equals? file buffer-file-name)
          (progn
            (save-buffer)
            (previous-buffer))
        (find-file file))))

  (defun th-echo-file-name ()
    (interactive)
    (message
     (s-chop-prefix
      (projectile-project-root)
      (file-truename (buffer-name)))))
#+end_src
*** Keymaps
#+begin_src emacs-lisp
  (define-key global-map (kbd "<f1>") 'helm-descbinds)

  (define-key global-map (kbd "<f2>")
    (lambda ()
      (interactive)
      (th-toggle-file (concat user-emacs-directory "emacs.org"))))

  (define-key global-map (kbd "C-x <f2>")
    (lambda ()
      (interactive)
      (split-window-below)
      (balance-windows)
      (windmove-down)
      (th-toggle-file (concat user-emacs-directory "emacs.org"))))

  (define-key global-map (kbd "<f3>")
    (lambda ()
      (interactive)
      (th-toggle-file (concat user-emacs-directory "todo.org"))))

  (define-key global-map (kbd "<f4>")
    (lambda ()
      (interactive)
      (let ((content initial-scratch-message)
            (buf "*scratch*"))
        (when (get-buffer buf)
          (setq content ""))
        (switch-to-buffer buf)
        (insert content))))

  (define-key global-map (kbd "<f5>")
    (lambda ()
      (interactive)
      (let ((doe t))
        (if debug-on-error
            (setq doe nil))
        (setq debug-on-error doe)
        (message "debug-on-error set to %s" doe))))

  (define-key global-map (kbd "C-x ?") 'th-echo-file-name)
#+end_src
** magit and git
*** magit
#+begin_src emacs-lisp
  (require 'magit)

  (defun th-magit-status ()
    (interactive)
    (save-some-buffers t)
    (magit-status))

  (global-set-key (kbd "C-x g") 'th-magit-status)
  (global-set-key (kbd "M-m") 'th-magit-status)

  (setq magit-save-some-buffers 'dontask)
  (setq magit-last-seen-setup-instructions "1.4.0")

  (defadvice magit-status (around magit-fullscreen activate)
    (window-configuration-to-register :magit-fullscreen)
    ad-do-it
    (delete-other-windows))

  (defadvice magit-mode-bury-buffer (after magit-restore-screen activate)
    "Restores the previous window configuration and kills the magit buffer"
    (jump-to-register :magit-fullscreen))

  (define-key magit-status-mode-map (kbd "q") 'magit-mode-bury-buffer)
  (define-key magit-status-mode-map (kbd "M-m") 'magit-mode-bury-buffer)
#+end_src
*** git
#+begin_src emacs-lisp
  (setq git-commit-summary-max-length 79)
#+end_src
** Flycheck
#+begin_src emacs-lisp
  (require 'flycheck)
  (global-set-key (kbd "C-x C-n") 'flycheck-next-error)
  (global-set-key (kbd "C-x C-p") 'flycheck-previous-error)
  (global-set-key (kbd "C-c C-SPC")
                  (lambda ()
                    (interactive)
                    (th-toggle-buffer 'flycheck-list-errors "*Flycheck errors*")))

  (with-eval-after-load 'flycheck
    (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
#+end_src
** emmet
#+begin_src emacs-lisp
  (add-hook 'sgml-mode-hook 'emmet-mode) ;; Auto-start on any markup modes
  (add-hook 'css-mode-hook  'emmet-mode) ;; enable Emmet's css abbreviation.
  (add-hook 'emmet-mode-hook
            (lambda ()
              (setq emmet-indentation 2))) ;; indent 2 spaces.
#+end_src
** ace-jump / avy
#+begin_src emacs-lisp
  (define-key global-map (kbd "M-n") 'avy-goto-word-1)
  (define-key global-map (kbd "C-l") 'avy-goto-word-1)
  (define-key global-map (kbd "M-p") 'ace-window)
#+end_src
** Kill ring
#+begin_src emacs-lisp
  (define-key global-map (kbd "C-x y") 'helm-show-kill-ring)
#+end_src
** expand-region
#+begin_src emacs-lisp
  (require 'expand-region)
  (global-set-key (kbd "M-l") 'er/expand-region)
  (global-set-key (kbd "C-M-l") 'er/contract-region)
#+end_src
** multiple-cursors
#+begin_src emacs-lisp
  (require 'multiple-cursors)
  (global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
  (global-set-key (kbd "C-x C-l") 'mc/mark-next-like-this)
  (global-set-key (kbd "C-x C-h") 'mc/mark-previous-like-this)
  (global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)
 #+end_src
** neotree
#+begin_src emacs-lisp
  (defun neotree-toggle-windows ()
    (interactive)
    (neotree-toggle)
    (balance-windows))

  (global-set-key (kbd "C-x M-f") 'neotree-toggle-windows)
  (global-set-key (kbd "M-n") 'neotree-toggle-windows)
#+end_src
** ffap
#+begin_src emacs-lisp
  ;; This literally has to exist in emacs, I just can't figure out where it is.
  (global-set-key
   (kbd "C-M-f")
   (lambda ()
     (interactive)
     (let ((fn (ffap-file-at-point)))
       (if fn
           (find-file fn)
         (error "No file found at point")))))
#+end_src
** dired
#+begin_src emacs-lisp
  (defun th-kill-all-dired-buffers ()
    (interactive)
    (mapc
     (lambda (buffer)
       (when (eq 'dired-mode (buffer-local-value 'major-mode buffer))
         (kill-buffer buffer)))
     (buffer-list)))

  (define-key dired-mode-map (kbd "q") 'th-kill-all-dired-buffers)
#+end_src
* Setup and options
** Options and settings
#+begin_src emacs-lisp
  (require 's)
  (fset 'yes-or-no-p 'y-or-n-p)
  (setq-default indicate-empty-lines t)

  (setq debug-on-error nil)

  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (mouse-wheel-mode -1)
  (scroll-bar-mode -1)

  (setq compilation-read-command nil)

  (setq inhibit-startup-screen t
        initial-scratch-message ";; *scratch*\n\n")

  (setq backup-inhibited t
        make-backup-files nil
        auto-save-default nil)

  (setq backup-by-copying t)

  ;; Save all tempfiles in $TMPDIR/emacs$UID/
  (defconst emacs-tmp-dir
    (format "/tmp/emacs-%s/" (user-uid)))
  (make-directory emacs-tmp-dir t)
  (setq backup-directory-alist
        `(("." . ,emacs-tmp-dir)))
  (setq auto-save-file-name-transforms
        `((".*" ,emacs-tmp-dir t)))
  (setq temporary-file-directory emacs-tmp-dir)

  (setq auto-save-list-file-prefix
        emacs-tmp-dir)

  (setq auto-save-interval 90000
        auto-save-timeout 3600)

  (defadvice save-buffer (around save-buffer-as-root-around activate)
    "Use sudo to save the current buffer."
    (interactive "p")
    (if (and (buffer-file-name) (not (file-writable-p (buffer-file-name))))
        (let ((buffer-file-name (format "/sudo::%s" buffer-file-name)))
      ad-do-it)
      ad-do-it))

  (setq echo-keystrokes 0.4
        standard-indent 4
        tab-always-indent 'complete)

  (setq-default comment-column 42
                fill-column 78
                indent-tabs-mode nil
                tab-width 2
                word-wrap t)


  (put 'downcase-region 'disabled nil)

  (show-paren-mode t)
  (electric-pair-mode t)
  (global-auto-revert-mode t)
  (auto-fill-mode t)
  (auto-save-mode -1)
#+end_src
** Browser setup
This uses the `www` command from the dotfiles repo and puts browser
configuration outside of emacs.
#+begin_src emacs-lisp
  (setq browse-url-browser-function 'browse-url-generic
        browse-url-generic-program "www")
#+end_src
** Backups
#+begin_src emacs-lisp
  (defvar --backup-directory (concat user-emacs-directory "backups"))
  (if (not (file-exists-p --backup-directory))
          (make-directory --backup-directory t))
  (setq backup-directory-alist `(("." . ,--backup-directory)))
  (setq make-backup-files nil      ; backup of a file the first time it is saved.
        backup-by-copying t        ; don't clobber symlinks
        version-control nil        ; version numbers for backup files
        delete-old-versions t      ; delete excess backup files silently
        delete-by-moving-to-trash nil
        kept-old-versions 1        ; oldest versions to keep when a new numbered backup is made (default: 2)
        kept-new-versions 1        ; newest versions to keep when a new numbered backup is made (default: 2)
        auto-save-default nil      ; auto-save every buffer that visits a file
        auto-save-timeout 9000     ; number of seconds idle time before auto-save (default: 30)
        auto-save-interval 900000  ; number of keystrokes between auto-saves (default: 300)
        )
#+end_src
** Window management
#+begin_src emacs-lisp
  ;; Try to make emax split vertically when possible
  (setq split-height-threshold nil)
  (setq split-width-threshold 0)
#+end_src
*** Emacs-like
#+begin_src emacs-lisp
  (define-key global-map (kbd "C-x 2")
    (lambda ()
      (interactive)
      (split-window-vertically)
      (balance-windows)
      (windmove-down)))

  (define-key global-map (kbd "C-x 3")
    (lambda ()
      (interactive)
      (split-window-horizontally)
      (balance-windows)
      (windmove-right)))

#+end_src
*** vim-like
#+begin_src emacs-lisp
  (global-set-key (kbd "C-x h") 'windmove-left)
  (global-set-key (kbd "C-x j") 'windmove-down)
  (global-set-key (kbd "C-x k") 'windmove-up)
  (global-set-key (kbd "C-x l") 'windmove-right)

  (defun th-kill-window ()
    "Kill the window. If it's the last one in the frame and the server is running, kill the frame."
    (interactive)
    (if (and (one-window-p) (server-running-p))
        (progn
          (save-buffer)
          (delete-frame))
      (progn
        (delete-window)
        (save-excursion
          (balance-windows)))))

  (global-set-key (kbd "C-q") 'th-kill-window)
#+end_src
** Linum
#+begin_src emacs-lisp
  (global-linum-mode 0)
  (setq linum-format " %4d ")

  (defvar th-linum-modes
    '(eshell-mode wl-summary-mode compilation-mode org-mode
                  dired-mode doc-view-mode image-mode))

  (defun th-linum-filter ()
    "Disable linum-mode if the file mode is in the defined list"

    (unless (or
             (-contains? th-linum-modes major-mode)
             (string-match "*" (buffer-name)))
      (linum-mode 1)))

  (add-hook 'find-file-hook 'th-linum-filter)

  (fringe-mode 12)
  (setq scroll-step 10)
#+end_src
** Clean mode line
#+begin_src emacs-lisp
  ;; http://www.masteringemacs.org/articles/2012/09/10/hiding-replacing-modeline-strings/
  (defvar mode-line-cleaner-alist
    `((paredit-mode . " ()")
      (eldoc-mode . "")
      (abbrev-mode . "")
      (auto-fill-mode "af")
      (helm-mode "")
      (magit-auto-revert-mode "")
      (undo-tree-mode "")

      ;; Major modes
      (help-mode . "")
      (fundamental-mode . "0")
      (python-mode . "Py")
      (emacs-lisp-mode . "El")))

  (defun clean-mode-line ()
    (interactive)
    (cl-loop for cleaner in mode-line-cleaner-alist
          do (let* ((mode (car cleaner))
                   (mode-str (cdr cleaner))
                   (old-mode-str (cdr (assq mode minor-mode-alist))))
               (when old-mode-str
                   (setcar old-mode-str mode-str))
                 ;; major mode
               (when (eq mode major-mode)
                 (setq mode-name mode-str)))))

  (add-hook 'after-change-major-mode-hook 'clean-mode-line)
#+end_src
** Aborting and stopping
#+begin_src emacs-lisp
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)
  (global-unset-key (kbd "C-x C-c"))
  (global-set-key (kbd "<f11>") 'save-buffers-kill-emacs)
#+end_src
** uniquify
#+begin_src emacs-lisp
  (require 'uniquify)
  (setq uniquify-buffer-name-style 'forward)
#+end_src
** Spotify

#+begin_src emacs-lisp
  ;; work-specific things that are in other repositories because secrets.
  (require 'f)
  (setq work-path "~/git/payments-elisp/")
  (when (f-dir? work-path)
    (add-to-list 'load-path work-path))

  (when (f-dir? work-path)
    (require 'payments))
#+end_src
** custom

Does anyone even like custom? I find it incredibly annoying.

#+begin_src emacs-lisp
  (setq custom-file "~/.emacs.d/custom.el")
  (unless (file-exists-p custom-file)
    (with-temp-buffer (write-file custom-file)))
  (load custom-file)
#+end_src
