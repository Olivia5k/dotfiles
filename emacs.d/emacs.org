#+TITLE: init file for Emacs
#+AUTHOR: Lowe Thiderman
#+EMAIL: lowe.thiderman@gmail.com
#+CREDIT: Howard Abrams <howard.abrams@gmail.com> (github.com/howardabrams/dot-files)

This is my emacs setup, and it's a constant work in progress. The current
setup is like this, as an [[https://orgmode.org][org-mode]] plain text file that compiles down to an
elisp file that is executed upon startup. org-mode was chosen since it helps
organize the file, gives nice folding, and sets up for writing inline
documentation in a style similar to literate programming.

* Common Lisp

  This seems to be painfully required...

  #+begin_src emacs-lisp
    (require 'cl)
  #+end_src

* Custom

  I don't particularly like custom, but hey, it's here.

  #+begin_src emacs-lisp
    (setq custom-file "~/.emacs.d/custom.el")
    (unless (file-exists-p custom-file)
      (with-temp-buffer (write-file custom-file)))
    (load custom-file)
  #+end_src

* Package configuration
** Path configuration

   This sets up so that packages and themes can be loaded properly.

   #+begin_src emacs-lisp
     (add-to-list 'load-path (concat user-emacs-directory "lisp"))

     (setq custom-theme-directory (concat user-emacs-directory "themes"))

     (dolist
         (path (directory-files custom-theme-directory t "\\w+"))
       (when (file-directory-p path)
         (add-to-list 'custom-theme-load-path path)))
   #+end_src

** Preamble and setup

   Sets up the repositories to get packages from. Extra and more frequently
   updated repositories outside of MELPA are added. Order matters.

   #+begin_src emacs-lisp
     (require 'package)

     (setq package-archives
           '(("org"       . "http://orgmode.org/elpa/")
             ("tromey"    . "http://tromey.com/elpa/")
             ("gnu"       . "http://elpa.gnu.org/packages/")
             ("melpa"     . "http://stable.melpa.org/packages/")
             ("marmalade" . "http://marmalade-repo.org/packages/")))

     (package-initialize)
   #+end_src

** use-package

   Using [[https://github.com/jwiegley/use-package][use-package]] to automatically install certain packages, as
   well as the ease of lazily loading them.

   #+begin_src emacs-lisp
     (unless (package-installed-p 'use-package)
       (package-refresh-contents)
       (package-install 'use-package))

     (setq use-package-always-ensure t)
     (require 'use-package)
   #+end_src

* Libraries

  These make working with emacs a bit more pleasurable and modern.

  #+begin_src emacs-lisp
    (use-package cl-lib)
    (use-package dash)
    (use-package f)
    (use-package s)
  #+end_src

* Interface
** avy

   avy is a nice little package that helps with quick navigation. Using =C-l=
   you get a prompt for a character. Press one and that character will get
   guiding characters that help you move to a specific one in a keystroke. Try
   it out and you might change your movement habits forever.

   #+begin_src emacs-lisp
     (use-package avy
       :ensure t
       :commands avy-goto-word-1 avy-goto-char-1 avy-goto-line avy-goto-char-timer
       :bind
       ("C-l"     . avy-goto-word-1))
   #+end_src

** darktooth

   I really like the darktooth theme! This sets that up and also makes some
   overrides. As much as I like it, it has some things I want to improve on!

   #+begin_src emacs-lisp
     (use-package darktooth-theme
       :ensure t)

     (load-theme 'darktooth)

     ;; On the workstation, the font should be big. Elsewhere, make it smaller.
     (set-frame-font
      (if (s-equals? (system-name) "dragonwing")
          "Iosevka-12"
        "Iosevka-10"))

     (defun th-toggle-font ()
       "Toggles between smaller and larger fonts"
       (interactive)
       (set-frame-font
        (if (s-contains? "-18-" (frame-parameter nil 'font))
            "Iosevka-10"
          "Iosevka-12")))

     (global-set-key (kbd "M-1") 'th-toggle-font)

     ;; This is called at the very bottom of emacs.org. See comments there.
     (defun th-fix-darktooth ()
       "Things that make darktooth a theme more suited for me."

       (let ((faces (face-list)))
         ;; This is to fix the lack of boldness in darktooth
         (mapc
          (lambda (face)
            (set-face-attribute face nil ':bold t))
          (-filter
           (lambda (face)
             (let ((fn (symbol-name face)))
               (or (s-starts-with? "font-lock" fn)
                   (s-starts-with? "org-level" fn)
                   (s-starts-with? "rainbow" fn))))
           faces))

         ;; This is to fix the fact that darktooth has foreground colorization for
         ;; avy, which to my eyes don't stick out enough.
         (mapc
          (lambda (face)
            (set-face-attribute face nil ':inverse-video t))
          (-filter
           (lambda (face)
             (let ((fn (symbol-name face)))
               (s-starts-with? "avy-lead" fn)))
           faces)))

       ;; Also make the linum and the fringe stand out more!
       (set-face-attribute 'linum nil :background "#1D2021" :foreground "#7C6F64")
       (set-face-attribute 'fringe nil :background "#3C3836")

       ;; Also strings and types are the same, which is bad. Make strings greener.
       (set-face-attribute 'font-lock-string-face nil :foreground "#427B58")
       ;; And functions do not stand out at all...
       (set-face-attribute 'font-lock-function-name-face nil :foreground "#FE8019")

       (message "darktooth fixed"))
   #+end_src

** popwin

   popwin is a little library that makes most special kinds of buffers appear
   as smaller popups rather than just take up the entire space of a buffer.

   #+begin_src emacs-lisp
     (use-package popwin
       :bind
       ("C-x C-k" . popwin:close-popup-window)

       :config
       (popwin-mode 1)
       ;; It was apparently tricky to make use-package map to what's just a keymap
       (global-set-key (kbd "C-x p") popwin:keymap))
   #+end_src

** projectile

   projectile brings knowledge of your different projects into emacs. Sadly, I
   mostly only use =C-c p p=, which brings up a helm selector for all visited
   projects. projectile itself is much more powerful than that, I just never
   got around to using it much more.

   #+begin_src emacs-lisp
     (use-package projectile
       :bind (("C-x f" . projectile-find-file))

       :config
       (projectile-global-mode)
       (setq projectile-completion-system 'ivy
             projectile-mode-line nil))
   #+end_src

** Swiper / ivy / counsel

   [[https://github.com/abo-abo/swiper][swiper]] is a fuzzy completion library similar to helm, but is lighter, tons
   simpler to use and much easier to extend.

*** Base setup

   #+begin_src emacs-lisp
     (use-package ivy
       :bind (("C-s"     . swiper)
              ("C-M-s"   . counsel-git-grep)
              ("M-x"     . counsel-M-x)
              ("M-i"     . counsel-imenu)
              ("C-x y"   . counsel-yank-pop)
              ("C-c C-r" . ivy-resume))

       :config
       (setq ivy-use-virtual-buffers t)
       (setq ivy-count-format "(%d/%d) ")
       (setq ivy-height 20)
       (setq magit-completing-read-function 'ivy-completing-read)

       ;; So that we can do space separation in file name completions
       (setq ivy-re-builders-alist
             '((t . ivy--regex-ignore-order)))

       (ivy-mode 1))

     (use-package counsel
       :config
       ;; https://github.com/abo-abo/swiper/issues/685#issuecomment-249162962
       (setq counsel-find-file-ignore-regexp
             (concat
              ;; File names beginning with # or .
              "\\(?:\\`[#.]\\)"
              ;; File names ending with # or ~
              "\\|\\(?:\\`.+?[#~]\\'\\)")))
   #+end_src

*** Custom actions

    These commands add so that the z/s actions in buffer switching and file
    switching opens in a new split of the corresponding kind. I've missed this
    since I switched to emacs 18 months ago, damn.

    #+begin_src emacs-lisp
      (ivy-set-actions
       'projectile-find-file
       '(("z" (lambda (fn)
                (interactive)
                (split-window-below)
                (windmove-down)
                (find-file fn))
          "horz")
         ("s" (lambda (fn)
                (interactive)
                (split-window-right)
                (windmove-right)
                (find-file fn))
          "vert")))

      (ivy-set-actions
       'ivy-switch-buffer
       '(("z" (lambda (buf)
                (interactive)
                (split-window-below)
                (windmove-down)
                (switch-to-buffer buf))
          "horz")
         ("s" (lambda (buf)
                (interactive)
                (split-window-right)
                (windmove-right)
                (switch-to-buffer buf))
          "horz")))
    #+end_src

* Editing
** Adding current buffer to minibuffer

   Press =F3= to insert the full path of the current buffer into the
   minibuffer.

   #+begin_src emacs-lisp
     (define-key minibuffer-local-map [f3]
       (lambda () (interactive)
         (insert (file-truename
                  (buffer-name
                   (window-buffer (minibuffer-selected-window)))))))

   #+end_src

** Autocompletion

   #+begin_src emacs-lisp
     (require 'company)
     (require 'company-go)

     (setq company-tooltip-limit 20)                      ; bigger popup window
     (setq company-idle-delay .3)                         ; decrease delay before autocompletion popup shows
     (setq company-echo-delay 0)                          ; remove annoying blinking
     (setq company-begin-commands '(self-insert-command)) ; start autocompletion only after typing
   #+end_src

** Commenting code

   Comments lines or regions.

   #+begin_src emacs-lisp
     (defun th-comment-block ()
       (interactive)
       (let ((start (line-beginning-position))
             (end (line-end-position)))
         (when (region-active-p)
           (setq start (save-excursion
                         (goto-char (region-beginning))
                         (beginning-of-line)
                         (point))
                 end (save-excursion
                       (goto-char (region-end))
                       (end-of-line)
                       (point))))
         (comment-or-uncomment-region start end)))

     (global-set-key (kbd "M-;") 'th-comment-block)
   #+end_src

** Enhanced default keybindings
*** C-a
#+begin_src emacs-lisp
  (defun back-to-indentation-or-previous-line ()
    "Go to first non whitespace character on a line, or if already on the first
    non whitespace character, go to the beginning of the previous non-blank line."
    (interactive)
    (if (= (point) (save-excursion (back-to-indentation) (point)))
        (previous-line))
    (if (and (eolp) (bolp))
        (back-to-indentation-or-previous-line))
    (back-to-indentation))

  (global-set-key (kbd "C-a") 'back-to-indentation-or-previous-line)
#+end_src
*** C-e
#+begin_src emacs-lisp
  (defun move-end-of-line-or-next-line ()
    (interactive)
    (if (eolp)
        (progn
          (next-line)
          (if (bolp)
              (move-end-of-line-or-next-line))))
    (move-end-of-line nil))

  (global-set-key (kbd "C-e") 'move-end-of-line-or-next-line)
#+end_src
*** C-o and C-M-o
#+begin_src emacs-lisp
  (defun insertline-and-move-to-line (&optional up)
    "Insert a newline, either below or above depending on `up`. Indent accordingly."
    (interactive)
    (beginning-of-line)
    (if up
        (progn
          (newline)
          (forward-line -1))
      (move-end-of-line nil)
      (open-line 1)
      (forward-line 1))
    (indent-according-to-mode))

  (global-set-key (kbd "C-o") 'insertline-and-move-to-line)
  (global-set-key (kbd "C-M-o") (lambda ()
                                  (interactive)
                                  (insertline-and-move-to-line t)))
#+end_src
*** M-F
#+begin_src emacs-lisp
  (defun forward-word-to-beginning (&optional n)
    "Move point forward n words and place cursor at the beginning."
    (interactive "p")
    (let (myword)
      (setq myword
            (if (and transient-mark-mode mark-active)
                (buffer-substring-no-properties (region-beginning) (region-end))
              (thing-at-point 'symbol)))
      (if (not (eq myword nil))
          (forward-word n))
      (forward-word n)
      (backward-word n)))

  (global-set-key (kbd "M-f") 'forward-word-to-beginning)
#+end_src
** Entire line operation
#+begin_src emacs-lisp
  (global-set-key (kbd "M-k")
                  (lambda ()
                    (interactive)
                    (beginning-of-line)
                    (if (eq (point) (point-max))
                        (previous-line))
                    (kill-line 1)
                    (back-to-indentation)))

  (defun yank-entire-line ()
    (interactive)
    (save-excursion
      (beginning-of-line)
      (set-mark-command)
      (end-of-line)
      (kill-ring-save)))
#+end_src
** fill mode
#+begin_src emacs-lisp
  (auto-fill-mode 1)
  (set-fill-column 79)
#+end_src

** Joining lines

   The default behavior didn't really sit well with me.

   #+begin_src emacs-lisp
     (global-set-key (kbd "M-j") (lambda () (interactive) (join-line -1)))
   #+end_src

** Line duplication

   Duplicates a line or the current region. Is smart about copying the lines
   and not just where the region started or ended.

   #+begin_src emacs-lisp
     (defun duplicate-current-line-or-region (arg)
       "Duplicates the current line or region ARG times.
        If there's no region, the current line will be duplicated. However, if
        there's a region, all lines that region covers will be duplicated."
       (interactive "p")
       (let (beg end (origin (point)))
         (if (and mark-active (> (point) (mark)))
             (exchange-point-and-mark))
         (setq beg (line-beginning-position))
         (if mark-active
             (exchange-point-and-mark))
         (setq end (line-end-position))
         (let ((region (buffer-substring-no-properties beg end)))
           (dotimes (i arg)
             (goto-char end)
             (newline)
             (insert region)
             (setq end (point)))
           (goto-char (+ origin (* (length region) arg) arg)))))

     (global-set-key (kbd "C-x d") 'duplicate-current-line-or-region) ; fak u paredit <3
   #+end_src

** Save hooks

   Delete trailing whitespace on save. Also truncates empty lines at the end
   of the file.

   #+begin_src emacs-lisp
     (add-hook 'before-save-hook
               (lambda ()
                 (save-excursion
                   (save-restriction
                     (delete-trailing-whitespace)
                     (widen)
                     (goto-char (point-max))
                     (delete-blank-lines)))))
   #+end_src

** undo tree

   Visualizes states of undo. Really nice when you want to backtrack a bit to
   get an overview of what you just messed up.

   #+begin_src emacs-lisp
     (use-package undo-tree
       :bind
       (("C-z"     . undo-tree-undo)
        ("C-x C-z" . undo-tree-undo)
        ("C-M-z"   . undo-tree-redo)
        ("C-x u"   . undo-tree-visualize))

       :config
       (global-undo-tree-mode +1))
   #+end_src

** yas

   The canonical snippet library for emacs. Mostly works well, although it can
   come with questionable defaults every now and again.

   #+begin_src emacs-lisp
     (use-package yasnippet
       :config
       (yas-reload-all) ;; Without this, it doesn't load...
       (add-hook 'prog-mode-hook 'yas-minor-mode)
       (add-hook 'markdown-mode 'yas-minor-mode)
       (add-hook 'org-mode-hook 'yas-minor-mode))
   #+end_src

* Major modes
** compile

   The compilation concept inside of emacs is great, but its defaults is a
   tad... old fashioned.

*** Settings

    #+begin_src emacs-lisp
      (use-package compile
        :bind (:map compilation-mode-map
               ("q" . th-quit-compilation-buffer)
               ;; `C-c l` is because that same command is used in golang and others
               ("C-c l" . th-toggle-maximize-buffer)

               :map go-mode-map
               ("C-c l" . th-maximize-log))

        :init
        (setq compilation-always-kill t
              compilation-ask-about-save nil
              compilation-auto-jump-to-first-error nil
              compilation-scroll-output t)

        (defun th-toggle-maximize-buffer (&optional buffer-name)
          "Maximize buffer"
          (interactive)
          (if (= 1 (length (window-list)))
              (jump-to-register '_)
            (progn
              (window-configuration-to-register '_)
              (if buffer-name
                  (switch-to-buffer buffer-name))
              (delete-other-windows))))

        (defun th-maximize-log ()
          (interactive)
          (th-toggle-maximize-buffer "*compilation*"))

        (defun th-quit-compilation-buffer ()
          ;; TODO: Maybe this can be done with advice instead?
          (interactive)
          (if (= 1 (length (window-list)))
              (jump-to-register '_)
            (quit-window))))
    #+end_src

** elisp

   Options and settings for hacking on emacs itself.

   #+begin_src emacs-lisp
     (use-package lispy
       :bind (:map lispy-mode-map
                   ;; This one just needs to be overwritten
                   ("M-o" . th-org/body)))

     (add-hook 'emacs-lisp-mode-hook 'lispy-mode)
     (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
     (add-hook 'emacs-lisp-mode-hook 'paredit-mode)
     (add-hook 'emacs-lisp-mode-hook 'rainbow-identifiers-mode)

     ;; pls no .elc
     (add-hook
      'emacs-lisp-mode-hook
      (lambda ()
        (make-local-variable 'after-save-hook)
        (add-hook
         'after-save-hook
         (lambda ()
           (if (file-exists-p (concat buffer-file-name "c"))
               (delete-file (concat buffer-file-name "c")))))))

     (defun th-buffer-or-region (action-name buffer-func region-func)
       (let ((s "Buffer"))
         (if (use-region-p)
             (progn
               (funcall region-func (region-beginning) (region-end))
               (keyboard-escape-quit)
               (setq s "Region"))
           (funcall buffer-func))

         (message "buffer-or-region: %s %s" s action-name)))

     (defun eval-buffer-or-region ()
       (interactive)
       (th-buffer-or-region "eval" 'eval-buffer 'eval-region))

     (define-key emacs-lisp-mode-map (kbd "C-c C-e") 'eval-buffer-or-region)
   #+end_src

** golang

   These are my Go tricks. They are fairly opinionated, but once they work well
   enough I think I want to bring them to the upstream go-mode somehow!
   [[https://github.com/dominikh/go-mode.el/pull/117][It started happening!]]

*** Ideas
**** TODO Compile in background
**** TODO Compile buffer recognition of tests
**** TODO Duplicate test function
**** TODO Toggle pointer to structs in file
**** TODO Toggle error as return value
**** TODO Template for error if nil (en)
**** TODO Replace inside function

#+begin_src emacs-lisp
  (require 'go-mode)
#+end_src

*** Package and hooks

    Load the base go-mode package and set up the hooks.

    #+begin_src emacs-lisp
      (use-package go-mode
        :bind
        ("C-c r"   . go-rename)
        ("C-c i"   . go-goto-imports)
        ("C-c C-i" . go-remove-unused-imports)
        ("C-c d"   . godoc)
        ("C-c C-o" . th-go-guru/body)

        :init
        (defun th-go-hook ()
          (add-hook 'before-save-hook 'gofmt-before-save)
          (set (make-local-variable 'company-backends) '(company-go))
          (company-mode)
          (flycheck-mode 1))

        (defhydra th-go-guru (:exit t)
          ("d" go-guru-describe)
          ("f" go-guru-freevars)
          ("i" go-guru-implements)
          ("c" go-guru-peers)  ; c for channel
          ("r" go-guru-referrers)
          ("j" go-guru-definition) ; j for jump
          ("p" go-guru-pointsto)
          ("s" go-guru-callstack) ; s for stack
          ("e" go-guru-whicherrs) ; e for error
          ("<" go-guru-callers)
          (">" go-guru-callees)
          ("x" go-guru-expand-region)) ;; x for expand

        :config
        (require 'go-guru)
        (add-hook 'go-mode-hook 'th-go-hook)
        (add-hook 'go-mode-hook 'go-eldoc-setup))

      (use-package company-go)
      (use-package go-eldoc)

    #+end_src

*** goto functions

    #+begin_src emacs-lisp
      ;; These were all moved into upstream! Yay open source <3
      (define-key go-mode-map (kbd "C-c g") 'go-goto-map)
    #+end_src

*** Coverage functions

    Shows coverage for the current go file. Deletes other windows.

    #+begin_src emacs-lisp
      (defun th-go-coverage ()
        "Toggle coverage mode for the current buffer"
        (interactive)

        (save-excursion
          (let ((bn (buffer-name)))
            (if (s-contains? "<gocov>" bn)
                (progn
                  (windmove-left)
                  (th-go-test-buffer-p))

              (if (s-contains? "_test.go" bn)
                  (progn
                    (windmove-left)
                    (th-go-coverage-p))
                (windmove-right)
                (if (not (s-contains? "<gocov>" (buffer-name)))
                    (progn
                      (windmove-left)
                      (th-go-coverage-p))
                  (windmove-left)
                  (th-go-test-buffer-p)))))))

      (defun th-go-coverage-p ()
        (delete-other-windows)
        (go-coverage (concat (projectile-project-root) "cover.out")))

      (define-key go-mode-map (kbd "C-c c") 'th-go-coverage)
    #+end_src

*** Test file view

    Brings up a split view of a single file and it's corresponding test file.
    The test file will be created if it does not already exist.

    #+begin_src emacs-lisp
      (defun th-go-test-buffer-p ()
        (let* ((bname (buffer-file-name))
               (left "")
               (right ""))

          (if (s-suffix? "_test.go" bname)
              (setq left (th-go-alternate-file bname)
                    right bname)
            (setq left bname
                  right (th-go-alternate-file bname)))

          (find-file left)
          (delete-other-windows)
          (split-window-horizontally)
          (windmove-right)
          (find-file right)))

      (defun th-go-test-buffer ()
        (interactive)
        (th-go-test-buffer-p))

      (defun th-go-test-buffer-split (file)
        ;; If we happen to be on the test file when splitting, go left once
        (when (th-go-test-file-p (buffer-file-name (get-buffer helm-current-buffer)))
          (windmove-left))

        (let ((fn (format "%s/%s.go" (projectile-project-root) file)))
          (split-window-below)
          (find-file fn)
          (windmove-right)
          (split-window-below)
          (find-file (th-go-alternate-file fn))
          (balance-windows)))

      (defun th-go-alternate-file (fn)
        "If fn is code, return path to test file and vice versa"

        (if (s-suffix? "_test.go" fn)
            (s-replace "_test.go" ".go" fn)
          (s-replace ".go" "_test.go" fn)))

      (defun th-go-test-file-p (&optional fn)
        "Returns boolean if the file name given is a test file"
        (s-contains? "_test.go"
                     (if (not fn)
                         (buffer-file-name)
                       fn)))

      (defun th-go-alternate ()
        "Go to the alternate file; code or test."
        (interactive)
        (find-file (th-go-alternate-file (buffer-name))))

      (define-key go-mode-map (kbd "C-c a") 'th-go-alternate)
    #+end_src

*** Single test execution

    Helper function that lets you execute a single test rather than the entire
    suite. Run with =C-M-x= on a test file. When run in a non-test file, the
    most recently executed test will be run again.

    #+begin_src emacs-lisp
      (defun th-go-get-test-above ()
        "Gets the name of the test above point"
        (save-excursion
          (re-search-backward "^func \\(Test\\|Example\\)" nil t)
          (forward-word 2)
          (thing-at-point 'symbol t)))

      (defvar th-go-last-single-test "go test" "The last single test command that was run")

      (defun th-go-single-test ()
        "If in test file, run the test above point. If not, run the last run test."
        (interactive)
        (projectile-save-project-buffers)
        (when (th-go-test-file-p)
          (setq th-go-single-test (format "go test -v -run %s" (th-go-get-test-above))))
        (compile th-go-single-test))

      (define-key go-mode-map (kbd "C-M-x") 'th-go-single-test)
    #+end_src

*** Snippet helpers

    These are functions used inside of yas.

    #+begin_src emacs-lisp
      (defun th-go-get-type-signature ()
        "Get the signature of the closest type: (t *Type)"
        (save-excursion
          (re-search-backward "^type" nil t)
          (if (looking-at "type")
              (progn (forward-word 2)
                     (let ((s (symbol-name (symbol-at-point))))
                       (format "(%s *%s)" (s-downcase (s-left 1 s)) s)))
            "")))

    #+end_src

*** Compiling and executing

    Helper functions that make compiling and viewing the compilation log
    simpler.

    #+begin_src emacs-lisp
      (defun th-go-test ()
        (interactive)
        (projectile-save-project-buffers)
        ;; The server compile command should run in the root
        (compile "go test -coverprofile=cover.out"))

      (define-key go-mode-map (kbd "C-c C-c") 'th-go-test)

      (defun th-go-server-compile ()
        (interactive)
        (projectile-save-project-buffers)
        ;; The server compile command should run in the root
        (with-current-buffer (th-go-main-file-buffer)
          (compile "go build -v")))

      (defun th-go-main-file ()
        "Returns the main go file of the project"
        (let ((path (projectile-project-root)))
          (concat path (format "%s.go" (f-base path)))))

      (defun th-go-main-file-buffer ()
        "Returns the buffer of the main go file of the project"
        (get-file-buffer (th-go-main-file)))

      (defun th-go-modules ()
        "Get the paths to all modules found in the project"
        (let ((path (projectile-project-root)))
          (cdr ;; Remove the ./
           (-uniq
            (-map
             (lambda (fn)
               ;; Add ./ so that go considers the modules as local and not remote
               (concat "./" (f-dirname fn)))
             (-filter
              ;; Return a list with all go files
              (lambda (fn) (s-contains? ".go" fn))
              (projectile-current-project-files)))))))

      (define-key go-mode-map (kbd "C-c C-k") 'popwin:close-popup-window)

    #+end_src

*** Docstring manipulation

    Update the function name of the docstring for the function you are
    visiting. Useful when renaming functions.

    #+begin_src emacs-lisp
      (defun th-go-update-docstring ()
        "Update the docstring of the current function to match the name it has."
        (interactive)
        (save-excursion
          ;; Since this will update if it is wrong, just call it and let it be.
          (th-go-goto-docstring)))

      (define-key go-mode-map (kbd "C-c M-d") 'th-go-update-docstring)
    #+end_src

*** Struct pointer refactoring

    =C-c C-m r=, a function to change the type signature of the current
    method. Will

    #+begin_src emacs-lisp
      (defun go--convert-type-name-to-receiver (tn)
        "Converts from the string \"Type\" to \"(t *Type)\""
        (format "(%s *%s)" (s-downcase (s-left 1 tn)) tn))

      (defun go--get-types (&optional file-name skip)
        "Return a list of all the types found in the current file.

      The strings returned are based on all lines that begin with
      '^type'. The letters 'type ' and the ending ' {' are both
      removed.

      If `skip' is provided, that type will not be included in the resulting list."

        (save-excursion
          (let ((fn (or file-name (buffer-file-name))))
            (-map
             (lambda (s) (s-chop-suffix " {" (s-chop-prefix "type " s)))
             (-filter
              (lambda (s)
                (if skip
                    ;; If skip is provided, also filter out that line
                    (and (s-prefix? "type " s)
                         (not (s-prefix? (format "type %s " skip) s)))
                  ;; Otherwise just return lines that start with "type"
                  (s-prefix? "type " s)))

              ;; Does emacs really don't have a cleaner way of getting lines in a
              ;; file? :/
              (with-temp-buffer
                (insert-file-contents fn)
                (split-string (buffer-string) "\n" t)))))))

      (defun go-refactor-method-receiver ()
        "Changes or removes the method receiver of the current function.

      A choice between all the types in the current file are
      interactively presented. Also presented is an item `<none>',
      which will remove the receiver if there is one.

      If there was a receiver and a new one is chosen,"
        ;; TODO(thiderman): We need to undo twice to undo this. Investigate.
        (interactive)
        (save-excursion
          (go-goto-function t)
          (forward-char 5)

          (let*
              ((empty "<none>")
               (current-var
                (save-excursion
                  (forward-char 1)
                  (thing-at-point 'symbol t)))
               (current-type
                (save-excursion
                  (forward-char 1)
                  (forward-word 2)
                  (thing-at-point 'symbol t)))
               (type (completing-read
                      "Type: "
                      (append (go--get-types (buffer-file-name) current-type)
                              (list empty))))
               (receiver (when (not (s-equals? type empty))
                           (go--convert-type-name-to-receiver
                            (car (s-split " " type))))))

            (cond
             ;; If we are looking at an opening parenthesis, there is already a method receiver
             ((looking-at "(")
              ;; Firstly, store the current receiver variable name.


              ;; Then, delete the existing one.
              (delete-region
               (point)
               (save-excursion
                 (forward-list 1)
                 (point)))
              ;; If we do not have a receiver (i.e. we chose 'empty) we should
              ;; delete the extra space.
              (if (not receiver)
                  (delete-char 1)
                ;; If there was a receiver previously and we set a new one, update the
                ;; variable name.
                (insert receiver)

                ;; And also update the variable name inside of the function.
                (when (and current-var receiver)
                  (go--refactor-symbol-in-function
                   current-var
                   (s-downcase (s-left 1 type))))))
             ((and (not (looking-at "(")) receiver)
              ;; There is no receiver, but we are adding one. Just insert it.
              (insert (format "%s " receiver)))))))

      (defun go--refactor-symbol-in-function (from to)
        "Changes instances of the symbol `from' into `to'.

      Assumes that point is on line defining the function we are replacing in."
        (save-excursion
          (beginning-of-line)
          (let ((start
                 (save-excursion
                   (forward-line -1)
                   (point)))
                (end
                 (save-excursion
                   ;; TODO(thiderman): Make a method that reliably moves to opening brace.
                   (end-of-line)
                   ;; In case of trailing whitespace...
                   (search-backward "{")
                   (forward-list 1)
                   (backward-char 1)
                   (point))))

            (replace-string from to t start end))))

      (define-prefix-command 'go-refactor-map)
      (define-key go-mode-map (kbd "C-c C-m") 'go-refactor-map)

      (define-key go-refactor-map (kbd "r") 'go-refactor-method-receiver)
    #+end_src

*** Debug toggler

    Touch or remove the =toggle/debug= file. Can be used in applications to
    easily increase the log level or similar operations.

    #+begin_src emacs-lisp
      (defun go-toggle-debug ()
        "Toggle the toggle/debug file"
        (interactive)
        (let* ((dir (concat (projectile-project-root) "toggle/"))
               (toggle "debug")
               (action "Toggled")
               (fn (concat dir toggle)))
          ;; Create the directory if it doesn't already exist
          (when (not (f-directory? dir))
            (make-directory dir))

          ;; Toggle the existence of the file
          (if (f-file? fn)
              (progn
                (f-delete fn)
                (setq action "Disabled"))
            (with-temp-buffer
              (write-file fn))
            (setq action "Enabled"))
          (message "%s %s" action toggle)))

      (define-key go-mode-map (kbd "C-c M-d") 'go-toggle-debug)
    #+end_src

*** Server runner

    Helper functions to run the executable that the current project produces.
    * =C-c s c= compiles the server
    * =C-c s s= starts or restarts the server
    * =C-c s b= visits the buffer with the output from the process

    One caveat is that the code currently assumes that you have a file called
    =<project-name>.go=.

    #+begin_src emacs-lisp
      ;; TODO: Make the argument part configurable
      (defun th-go-server-start ()
        "Start the server for the app"
        (interactive)
        (let* ((root (projectile-project-root))
               (name (f-base root))
               (procname (format "%s-server" name)))

          ;; If the server is already running, stop it; effectively making this a restart.
          (when (get-process procname)
            (th-go-server-stop))

          (start-process
           procname
           (format "*%s-server*" name)
           (concat root name)
           "server")

          ;; (set-process-filter proc 'th-go-server-insertion-filter)
          (message "Started %s server" name)))

      (defun th-go-server-stop ()
        "Stop the server for the app"
        (interactive)
        (let* ((name (f-base (projectile-project-root))))
          (delete-process
           (format "*%s-server*" name))
          (message "Stopped %s server" name)))

      ;; TODO: Move this to a non-golang place
      (defun th-npm-server-start ()
        "Start the server for the app"
        (interactive)
        (let* ((root (projectile-project-root))
               (name (format "%s-npm" (f-base root)))
               (procname (format "%s-server" name))
               (procbuffer (format "*%s*" procname))
               (dir (concat root "js/")))

          ;; If the server is already running, stop it; effectively making this a restart.
          (when (get-process procname)
            (th-npm-server-stop))

          (let ((default-directory dir))
            (start-process procname procbuffer "npm" "run" "dev"))

          (message "Started %s npm server" name)))

      (defun th-npm-server-stop ()
        "Stop the server for the app"
        (interactive)
        (let* ((name (f-base (projectile-project-root))))
          (delete-process
           (format "*%s-npm-server*" name))
          (message "Stopped %s server" name)))

      (defun th-go-server-buffer ()
        "Stop the server for the app"
        (interactive)
        (let* ((name (f-base (projectile-project-root))))
          (switch-to-buffer (format "*%s-server*" name))))

      ;; (defun th-go-server-insertion-filter (proc string)
      ;;   (with-current-buffer (process-buffer proc)
      ;;     ;; Insert the text, advancing the process marker.
      ;;     (goto-char (process-mark proc))
      ;;     (insert (format "Hehe <%s>" string))
      ;;     (set-marker (process-mark proc) (point))
      ;;     (goto-char (point-max))))

      (let ((m (define-prefix-command 'go-server-map)))
        (define-key m (kbd "s") 'th-go-server-start)
        (define-key m (kbd "k") 'th-go-server-stop)
        (define-key m (kbd "b") 'th-go-server-buffer)
        (define-key m (kbd "c") 'th-go-server-compile)
        (define-key m (kbd "n") 'th-npm-server-start))

      (define-key go-mode-map (kbd "C-c s") 'go-server-map)
    #+end_src

*** go-guru hydra

    Since there are so many commands to the guru, I feel like adding them to
    a hydra makes quite a lot of sense!

    #+begin_src emacs-lisp
      (define-key
        go-mode-map
        (kbd "C-c C-o")
        (defhydra th-go-guru (:exit t)
          "Guru commands"
          ("C-o" th-org-project "Project file")

          ("d" go-guru-describe "describe")
          ("f" go-guru-freevars "freevars")
          ("i" go-guru-implements "implements")
          ("c" go-guru-peers "peers (channels)")
          ("r" go-guru-referrers "referrers")
          ("j" go-guru-definition "definition")
          ("p" go-guru-pointsto "pointsto")
          ("s" go-guru-callstack "callstack")
          ("e" go-guru-whicherrs "whicherrs")
          ("<" go-guru-callers "callers")
          (">" go-guru-callees "callees")
          ("x" go-guru-expand-region "expand-region")))
    #+end_src

** logview-mode

   Nifty little mode that makes reading structured logs easier.

   #+begin_src emacs-lisp
     (use-package logview
       :init
       (add-hook
        'logview-mode-hook
        (lambda ()
          (linum-mode -1)
          (toggle-truncate-lines 1))))
   #+end_src

** org

   One of the obvious killer features of emacs! org is the kind of thing that
   makes emacs users into obnoxious cultists, but it is for a reason! Once you
   get into it, it'll be hard to look back.

*** Main setup

    #+begin_src emacs-lisp
      (use-package org
        :bind (:map org-mode-map
                    ("C-c ;" . org-edit-special)
               :map org-src-mode-map
                    ("C-c ;" . org-edit-src-exit))

        :init
        (setq
         org-confirm-babel-evaluate nil
         org-directory "~/org"
         org-fontify-emphasized-text t ;; fontify *bold* _underline_ /italic/ and so on
         org-hide-leading-stars t
         org-return-follows-link t
         org-special-ctrl-a/e t
         org-special-ctrl-k t
         org-src-fontify-natively t
         org-src-tab-acts-natively t
         org-src-window-setup 'current-window
         org-use-speed-commands t

         ;; When calculating percentages of checkboxes, count all boxes, not just
         ;; direct children
         org-hierarchical-checkbox-statistics t)

        :config
        (org-babel-do-load-languages
         'org-babel-load-languages
         '((emacs-lisp . t)
           (sql . t)
           (shell . t)))

        (org-bullets-mode 1))

      (use-package org-journal)
    #+end_src

*** Agenda and todo
**** Settings and options

     #+begin_src emacs-lisp
       (global-set-key (kbd "C-c a") 'org-agenda)

       (setq
        org-agenda-ndays 7
        org-agenda-files '("~/org/")
        org-agenda-show-all-dates t
        org-agenda-start-on-weekday nil
        org-archive-location "~/org/archive/%s::"
        org-log-done t) ;;timestamp when switching from todo to done

       (setq org-todo-keywords
             '("TODO(t)" "WORKING(w)" "WAITING(z)" "REVIEW(r)" "|" "DONE(d)" "INVALID(i)"))

       (setq org-todo-keyword-faces '(("WORKING" . org-scheduled-today)
                                      ("WAITING" . org-mode-line-clock)))

     #+end_src

**** Journal

     #+begin_src emacs-lisp
       (setq org-journal-dir "~/org/journal/"
             org-journal-file-format "%Y-%m-%d"
             org-journal-date-format "%A, %Y-%m-%d"
             org-journal-find-file 'find-file)

       ;; Since I am planning to do a lot of these, let's just pick a super simple keybind!
       (global-set-key (kbd "C-.") 'org-journal-new-entry)
     #+end_src

**** Capturing
     #+begin_src emacs-lisp
       (setq
        org-capture-templates
        `(("t" "Tasks" entry
           (file+headline "~/org/inbox.org" "Inbox")
           "* TODO %^{Task}")

          ("T" "Quick task" entry
           (file+headline "~/org/inbox.org" "Inbox")
           "* TODO %^{Task}\nSCHEDULED: %t\n"
           :immediate-finish t)

          ("i" "Interrupting task" entry
           (file+headline "~/org/inbox.org" "Inbox")
           "* STARTED %^{Task}"
           :clock-in :clock-resume)

          ("e" "Emacs idea" entry
           (file+headline "~/org/inbox.org" "Emacs")
           "* TODO %^{Task}"
           :immediate-finish t)

          ("E" "Event" entry
           (file+datetree+prompt "~/org/events.org" "Event")
           "* TODO %^{Task}\nSCHEDULED: %<%Y-%m-%d %H:%M>"
           :immediate-finish t)

          ("q" "Quick note" item
           (file+headline "~/org/inbox.org" "Quick notes"))

          ("r" "Recipe" entry
           (file+headline "~/org/food.org" "Recipes")
           "* [[%^{URL}][%^{Title}]]"
           )))
     #+end_src

**** Toggler keybindings

     #+begin_src emacs-lisp
       (define-key org-mode-map (kbd "C-c t")
         (lambda ()
           (interactive)
           (org-todo "TODO")))

       (define-key org-mode-map (kbd "C-c w")
         (lambda ()
           (interactive)
           (org-todo "WORKING")))

       (define-key org-mode-map (kbd "C-c z")
         (lambda ()
           (interactive)
           (org-todo "WAITING")))

       (define-key org-mode-map (kbd "C-c r")
         (lambda ()
           (interactive)
           (org-todo "REVIEW")))

       (define-key org-mode-map (kbd "C-c d")
         (lambda ()
           (interactive)
           (org-todo "DONE")))

       (define-key org-mode-map (kbd "C-c i")
         (lambda ()
           (interactive)
           (org-todo "INVALID")))

       (define-key org-mode-map (kbd "C-c SPC")
         (lambda ()
           (interactive)
           (org-todo 'none)))

     #+end_src

**** org-goto-for-project

     #+begin_src emacs-lisp
       (defun th-org-project ()
         "Go to the org project for the current repository.

       Go back if we're already in it."

         (interactive)
         (let* ((root (projectile-project-root))
                (name (car (last (s-split "/" (projectile-project-root)) 2))))
           (if (s-equals? (expand-file-name "~/org/") root)
               (progn
                 (save-buffer)
                 (previous-buffer))
             (find-file
              (format "~/org/%s.org" name)))))

     #+end_src

**** Archiving

     #+begin_src emacs-lisp
       (defun org-archive-done-tasks ()
         (interactive)
         (org-map-entries
          (lambda ()
            (org-archive-subtree)
            (setq org-map-continue-from (outline-previous-heading)))
          "/DONE" 'file))

       (define-key org-mode-map (kbd "C-c C-x C-a") 'org-archive-done-tasks)
     #+end_src

*** Hydra commands

    #+begin_src emacs-lisp
      (defhydra th-org (:exit t)
        "Org commands"
        ("C-o" th-org-project "Project file")
        ("c" org-capture "Capture")
        ("M-o" org-capture "Capture")
        ("s" (org-agenda nil "a") "Schedule")
        ("j" org-clock-goto "Current clocked task")
        ("a" org-todo-list "Agenda")
        ("t" org-tags-view "Tags"))

      (global-set-key (kbd "C-x C-o") 'th-org/body)
    #+end_src

** prog-mode

   Hooks that are needed for programming modes.

   #+begin_src emacs-lisp
     (add-hook 'emacs-lisp-mode-hook 'semantic-mode)
     (add-hook 'go-mode-hook 'semantic-mode)
     (add-hook 'python-mode-hook 'semantic-mode)
     (add-hook 'prog-mode-hook (lambda ()
                                 (auto-save-mode -1)))
     (add-hook 'text-mode-hook 'turn-on-fci-mode)
     (add-hook 'text-mode-hook 'auto-fill-mode)
   #+end_src

** python

   The major mode for editing Python in emacs. It honestly doesn't have much
   going for it, but hey.

   #+begin_src emacs-lisp
     (use-package python-mode
       :config
       (add-hook 'python-mode-hook 'flycheck-mode))

     (use-package anaconda-mode
       :config
       (add-hook 'python-mode-hook 'anaconda-mode))
   #+end_src

*** TODO Configure a working company backend

** Utility modes

   Several modes that I just install to have, without configuring. Grouped
   together because why not.

   #+begin_src emacs-lisp
     (use-package crontab-mode)
     (use-package csv-mode)
     (use-package dockerfile-mode)
     (use-package markdown-mode)
     (use-package nginx-mode)
     (use-package protobuf-mode)
     (use-package puppet-mode)
     (use-package ssh-config-mode)
     (use-package yaml-mode)
   #+end_src

** web-mode / vue-mode

   Enhanced editing of HTML with support for embedded languages.
   Used by vue-mode for templates.

*** Default setup

    #+begin_src emacs-lisp
      (use-package vue-mode)

      (use-package web-mode
        :init
        (setq web-mode-markup-indent-offset 2
              web-mode-attr-indent-offset 2)
        :config
        (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
        ;; If we're in vue-mode, make sure to reset it when we save.
        (add-hook 'after-save-hook
                  (lambda ()
                    (interactive)
                    (when (eq 'vue-mode major-mode)
                      (vue-mode)))))
    #+end_src

*** Browse to vue files only

    #+begin_src emacs-lisp
      (global-set-key (kbd "C-c v")
                      (lambda ()
                        (interactive)
                        (th-other-files-suffix "vue")))
    #+end_src

* Minor modes and utilities
** Alternate file visiting
*** Other files with same extension

    #+begin_src emacs-lisp
      (defun th-other-files-suffix (&optional suffix)
        "Browse between files of a certain kind in the current project.
      Defaults to the suffix of the current buffer if none is given.

      E.g. if you are visiting a .go file, this will list all other .go files.

      This is useful if you have backend and frontend code in the same repo."

        (interactive)
        (find-file
         (concat
          (projectile-project-root)
          (let ((suf (or suffix (f-ext (buffer-file-name))))
                (default-directory (projectile-project-root)))

            (completing-read
             (format "%s files: " suf)
             (-filter
              (lambda (x)
                (and
                 (s-suffix? (concat "." suf) x)
                 ;; Filter out test files, backup files and the current file
                 (not (s-contains? "test" x))
                 (not (s-contains? ".#" x))
                 (not (s-contains? x (buffer-file-name)))))
              (projectile-get-repo-files)))))))

      (global-set-key (kbd "C-x a") 'th-other-files-suffix)
    #+end_src

*** Other files with the same base name

    #+begin_src emacs-lisp
      (defun th-other-files-same-base ()
        "Find other files that have the same base as the current
      one. Complete if there are multiple found.

      E.g. if you are visiting `user.go' and `User.vue' exists, visit
      that. If there is also a `UserPanel.vue', start completion
      between the matching files instead.

      This is useful if you have backend and frontend code in the same repo."

        (interactive)

        (let* ((base (f-base (buffer-file-name)))
               (default-directory (projectile-project-root))
               (files (-filter
                       (lambda (x)
                         (and
                          (s-prefix? (downcase base)
                                     (downcase (f-base (f-filename x))))
                          ;; Filter out test files, backup files and the current file
                          (not (s-contains? "test" x))
                          (not (s-contains? ".#" x))
                          (not (s-contains? x (buffer-file-name)))))
                       (projectile-get-repo-files))))
          (cond
           ((= (length files) 1)
            (find-file (car files)))

           ((> (length files) 1)
            (find-file
             (completing-read "Alt files: " files)))

           (t
            (error "No alternate file for %s" (buffer-name))))))

      (global-set-key (kbd "C-x C-a") 'th-other-files-same-base)
    #+end_src

** Buffer toggles

   F1: `helm-descbinds` (set from helm config above)
   F2: Open this file
   F3: Open main org file
   F4: Scratch buffer
   F5: Toggle debug mode
   C-x ?: Print current file name relative to project root

*** Functions

    #+begin_src emacs-lisp
      (defun th-toggle-buffer (func name &optional kill-window)
        "Toggle or destroy a buffer, depending on if it exists or not.

        The `func` argument should be a callable that toggles the buffer.
        The `name` argument is a substring of the buffer that should be matched."
        (interactive)
        (let ((done nil))
          (loop for buffer being the buffers
                do (let ((bname (buffer-name buffer)))
                     (when (s-contains? name bname)
                       (if kill-window
                           (progn
                             (select-window (get-buffer-window buffer))
                             (kill-buffer-and-window)
                             (message "Killed %s" bname))
                         (progn
                           (kill-buffer buffer)
                           (message "%s toggled away" bname)))
                       (setq done t))))
          (unless done
            (funcall func))))

      (defun th-toggle-file (path &optional no-save)
        (let ((file (file-truename path)))
          (if (s-equals? file buffer-file-name)
              (progn
                (when (not no-save)
                  (save-buffer))
                (previous-buffer))
            (find-file file))))

      (defun th-echo-file-name ()
        (interactive)
        (message
         (s-chop-prefix
          (projectile-project-root)
          (file-truename (buffer-name)))))

      (defun switch-to-previous-buffer ()
        "Switch to previously open buffer.
      Repeated invocations toggle between the two most recently open buffers."
        (interactive)
        (switch-to-buffer (other-buffer (current-buffer) 1)))
      (global-set-key (kbd "C-x C-b") 'switch-to-previous-buffer)
    #+end_src

*** Keymaps

    #+begin_src emacs-lisp
      (define-key global-map (kbd "<f2>")
        (lambda ()
          (interactive)
          (th-toggle-file (concat user-emacs-directory "emacs.org"))))

      (define-key global-map (kbd "C-x <f2>")
        (lambda ()
          (interactive)
          (split-window-below)
          (balance-windows)
          (windmove-down)
          (th-toggle-file (concat user-emacs-directory "emacs.org"))))

      (define-key global-map (kbd "<f3>")
        (lambda ()
          (interactive)
          (th-toggle-file "~/.logs/payments/info.log" t)
          (end-of-buffer)))

      (define-key global-map (kbd "<f4>")
        (lambda ()
          (interactive)
          (let ((content initial-scratch-message)
                (buf "*scratch*"))
            (when (get-buffer buf)
              (setq content ""))
            (switch-to-buffer buf)
            (insert content))))

      (define-key global-map (kbd "<f5>")
        (lambda ()
          (interactive)
          (let ((doe t))
            (if debug-on-error
                (setq doe nil))
            (setq debug-on-error doe)
            (message "debug-on-error set to %s" doe))))

      (define-key global-map (kbd "C-x ?") 'th-echo-file-name)
    #+end_src

** Configurationless utilities

   These are tools that are useful just by dropping them in and not doing any
   further configuration on them.

*** adaptive-wrap

    Nice little minor mode that visually aligns wrapping smarter than just in
    the beginning of the line.

    #+begin_src emacs-lisp
      (use-package adaptive-wrap)
    #+end_src

*** buffer-move

    Switch places of buffers.

    #+begin_src emacs-lisp
      (use-package buffer-move)
    #+end_src

*** company

    Completion backend. Daemon based and ridiculously fast.

    #+begin_src emacs-lisp
      (use-package company)
    #+end_src

*** diminish

    Clean up the modeline by removing certain minor modes.

    #+begin_src emacs-lisp
      (use-package diminish)
    #+end_src

*** fill-column-indicator

    Show a line at the end where the =wrap-column= ends.

    #+begin_src emacs-lisp
      (use-package fill-column-indicator)
    #+end_src

*** paradox

    Nicer list of packages. Supports upgrading and giving stars to github
    repositories.

    #+begin_src emacs-lisp
      (use-package paradox)
    #+end_src

*** paredit

    Powerful lisp editing. Comes with emacs, but updating it is nice.

    #+begin_src emacs-lisp
      (use-package paredit)
    #+end_src

*** restclient

    Nifty package that lets you make requests towards a REST sources and
    displays pretty versions of the

    #+begin_src emacs-lisp
      (use-package restclient)
    #+end_src

*** transpose-frame

    Move from vertically split to horizontally split frames.

    #+begin_src emacs-lisp
      (use-package transpose-frame)
    #+end_src

*** wrap-region

    Actually this one needs config and shouldn't be here...

    #+begin_src emacs-lisp
      (use-package wrap-region)
    #+end_src

*** xkcd

    View xkcd strips inside of emacs!

    #+begin_src emacs-lisp
      (use-package xkcd)
    #+end_src

** Context aware execution

   Exeucte different things depending on what's under point.

   #+begin_src emacs-lisp
     (defun context-execute ()
       "Context aware execution of what's under point"
       (interactive)
       (let ((symbol (context-get-whitespace-word)))
         (message "Executing: <%s>" symbol)

         (cond
          ;; JIRA tickets
          ((s-matches? "[A-Z][A-Z]+-[0-9]+" symbol)
           (context-visit-jira symbol))

          ;; URLs
          ((s-matches? "[a-z]+://" symbol)
           (browse-url symbol)))

         ))

     (defun context-get-whitespace-word ()
       "Get the whitespace delimited word under point."

       (let ((start (save-excursion (re-search-backward "\\(^\\| \\)")))
             (end (save-excursion (re-search-forward "\\( \\|$\\)"))))
         (s-trim (buffer-substring start end))))

     (defun context-visit-jira (ticket)
       "Visit the JIRA page"
       (interactive)
       (browse-url (concat context-jira-root "/browse/" ticket)))

     (defvar context-jira-root "https://jira.spotify.net" "Root URL for JIRA")

     (global-set-key (kbd "M-RET") 'context-execute)
     (global-set-key (kbd "C-x RET") 'context-execute)
   #+end_src

** environment-loader

   Take all =export= variables from a =.env= file in the current directory and
   set them into emacs. Useful if you are working with [[https://12factor.net/config][12 factor apps]].

   #+begin_src emacs-lisp
     (defun th-load-env (&optional dir)
       "Loads all environment variables inside of given file into emacs."
       (interactive)

       (let* ((fn (th-find-env-file dir))
              (hash (th-get-env-hash fn))
              (keys (hash-table-keys hash)))
         (mapcar
          (lambda (k)
            (setenv k (gethash k hash)))
          keys)
         (message "Loaded %s.env: %s"
                  (f-base fn)
                  (s-join ", " keys))))

     (defun th-find-env-file (&optional dir)
       "Find the .env file in the current directory.

     If `dir' is given, use that instead of current."

       (when (not dir)
         (setq dir default-directory))

       ;; Fetches the first file if there is only one - completing read if multiple.
       ;; TODO(thiderman): No error handling if there are no files
       (let* ((files (f-files dir
                              (lambda (file)
                                (equal (f-ext file) "env")))))
         (if (= 1 (length files))
             (car files)
           (completing-read "env: " files))))

     (defun th-get-env-hash (fn)
       "For a given filename, return a list of acons of env variables inside."
       (let ((table (make-hash-table :test 'equal)))
         (with-temp-buffer
           (insert-file fn)
           (beginning-of-buffer)
           (mapcar 'th--put-into-hash
            (th--get-env-lines-in-file)))
         table))

     (defun th--put-into-hash (s)
       (let* ((spl (s-split "=" (s-replace "export " "" s)))
              (key (car spl))
              (val (s-replace "\"" "" (cadr spl))))
         ;; `table' is set in the lexical scope of the callee
         (puthash key val table)))

     (defun th--get-env-lines-in-file ()
       (-filter
        (lambda (s) (s-starts-with? "export" s))
        (s-lines
         (buffer-substring-no-properties (point) (point-max)))))
   #+end_src

** dired

   =dired= seems pretty dated at first, but it's actually quite nice!

   #+begin_src emacs-lisp
     (require 'dired)
     (require 'dired-x)

     (add-hook 'dired-mode-hook 'dired-hide-details-mode)

     (setq-default dired-omit-files-p t) ; Buffer-local variable
     (setq dired-omit-files (concat dired-omit-files "\\|^\\..+$\\|.pyc$"))
     (setq dired-omit-mode t)
     (setq dired-hide-details-hide-information-lines t)
     (setq dired-hide-details-mode t)
     (setq diredp-hide-details-initially-flag t)

     (defun th-kill-all-dired-buffers ()
       (interactive)
       (mapc
        (lambda (buffer)
          (when (eq 'dired-mode (buffer-local-value 'major-mode buffer))
            (kill-buffer buffer)))
        (buffer-list)))

     (define-key dired-mode-map (kbd "q") 'th-kill-all-dired-buffers)
   #+end_src

** emmet

   =emmet= provides expansion on HTML, so you can write CSS-like strings in
   your HTML files and then do =C-j= and it will expand it out to the full
   tags. Very useful!

   #+begin_src emacs-lisp
     (use-package emmet-mode
       :init
       (setq emmet-indentation 2)

       :config
       (add-hook 'sgml-mode-hook 'emmet-mode)  ;; Auto-start on any markup modes
       (add-hook 'css-mode-hook  'emmet-mode)  ;; Enable Emmet's css abbreviation.
       (add-hook 'web-mode-hook  'emmet-mode))

     (use-package helm-emmet)
   #+end_src

** expand-region

   Classic plugin by magnars that manipulates the region based on known
   delimiters.

   #+begin_src emacs-lisp
     (use-package expand-region
       :bind
       ("M-l"   . er/expand-region)
       ("C-M-l" . er/contract-region))
   #+end_src

** ffap

   This is an extended version of =ffap= that will try to find the file at
   point and bring up a preconfigured helm session if nothing can be found.

   #+begin_src emacs-lisp
     ;; This literally has to exist in emacs, I just can't figure out where it is.
     (global-set-key
      (kbd "C-x M-f")
      (lambda ()
        (interactive)
        (let ((fn (ffap-file-at-point))
              (sym (symbol-name (symbol-at-point))))
          (if fn
              (find-file fn)
            (counsel-find-file sym)))))
   #+end_src

** fixme-mode

   Highlight TODO and other related keywords.

   #+begin_src emacs-lisp
     (use-package fixme-mode
       :config
       (add-hook 'prog-mode-hook 'fixme-mode)
       (setq fixme-mode-warning-words
             '("FIXME" "TODO" "BUG" "KLUDGE" "FIX" "FixMe" "HACK"
               "REFACTOR" "NOCOMMIT" "XXX")))
   #+end_src

*** TODO Add support for highlighting labels like TODO(thiderman)

** flycheck

   Error checking and linting done right! Comes pre-packaged for most modes!

   #+begin_src emacs-lisp
     (use-package flycheck
       :bind
       ("C-x C-n" . flycheck-next-error)
       ("C-x C-p" . flycheck-previous-error)

       :config
       (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
   #+end_src

** git and magit
*** git

    Default packages that make git usage pleasant with emacs.

    #+begin_src emacs-lisp
      (use-package gitconfig-mode)
      (use-package gitignore-mode)
      (use-package git-commit
        :init
        (setq git-commit-summary-max-length 79))

      ;; Move back and forth between commits <3
      (use-package git-timemachine)

      ;; List and edit gists on github.com <3
      (use-package gist)
    #+end_src

*** magit

    ~magit~ is by far the best git interface ever conceived.
    This setup makes sure that the magit buffers are spawned fullscreen and
    that the previous screen layout is restored when it is buried.

    #+begin_src emacs-lisp
      (use-package magit
        :bind (("C-x g" . th-magit-status)
               :map magit-status-mode-map
               ("q"   . magit-mode-bury-buffer)
               ;; In certain modes we want to just kill the window, not magit entirely
               :map magit-process-mode-map
               ("q"   . delete-window))

        :init
        (defun th-magit-status ()
          (interactive)
          (save-some-buffers t)
          (magit-status))

        (setq magit-save-some-buffers 'dontask)
        (setq magit-last-seen-setup-instructions "1.4.0")

        (defadvice magit-status (around magit-fullscreen activate)
          (window-configuration-to-register :magit-fullscreen)
          ad-do-it
          (delete-other-windows))

        (defadvice magit-mode-bury-buffer (after magit-restore-screen activate)
          "Restores the previous window configuration and kills the magit buffer"
          (jump-to-register :magit-fullscreen)))
    #+end_src

** Minor mode switching

   There are some minor modes that you might want to have enabled every now
   and again. This provides a nice hydra that lets you do many of them real
   quick.

   #+begin_src emacs-lisp
     (defhydra th-modeswitch ()
       "Switching minor modes"
       ("a" auto-fill-mode "Auto fill")
       ("e" th-load-env "Load 12FA env")
       ("f" fci-mode "Fill column")
       ("M-f" auto-revert-tail-mode "Revert tail (follow)")
       ("h" highlight-symbol-mode "Highlight symbol")
       ("j" text-scale-decrease "Font -")
       ("k" text-scale-increase "Font +")
       ("l" linum-mode "Line numbers")
       ("r" rainbow-identifiers-mode "Rainbow identifiers")
       ("t" toggle-truncate-lines "Truncate lines"))

     (global-set-key (kbd "C-x c") 'th-modeswitch/body)
   #+end_src

** move-text

   Moving lines up and down. Also tries to indent according to where it lands

   #+begin_src emacs-lisp
     (defun move-line-up ()
       (interactive)
       (transpose-lines 1)
       (forward-line -2)
       (indent-for-tab-command))

     (defun move-line-down ()
       (interactive)
       (forward-line 1)
       (transpose-lines 1)
       (forward-line -1)
       (indent-for-tab-command))

     (global-set-key [M-up] 'move-line-up)
     (global-set-key [M-down] 'move-line-down)
   #+end_src

** multiple-cursors

   Quickfast editing of multiple places at once.

   #+begin_src emacs-lisp
     (use-package multiple-cursors
       :bind
       ("C-x C-l" . mc/mark-next-like-this)
       ("C-x C-h" . mc/mark-previous-like-this))
   #+end_src

** Rainbows <3

   The rainbow modes bring nice colors to your code:

   * =rainbow-mode= colorizes strings like ~red~ and ~#405060~.
   * =rainbow-delimiters= colorizes parenthesis, brackets and other delimiters.
   * =rainbow-identifiers= colorizes variables in different colors.

   #+begin_src emacs-lisp
     (use-package rainbow-mode)
     (use-package rainbow-delimiters)
     (use-package rainbow-identifiers)
   #+end_src

** Rotate text

   #+begin_src emacs-lisp
     (use-package rotate-text
       :init
       (setq rotate-text-words '(("width" "height")
                                 ("left" "right" "top" "bottom")
                                 ("true" "false")
                                 ("==" "!=" "<=" ">=")))

       (setq rotate-text-symbols '(("true" "false")
                                   ("==" "!=" "<=" ">=")))
       :bind (("M-s" . rotate-text)))
   #+end_src

** visual-regexp-steroids

   Nice little mode to get a better search/replace experience.

   #+begin_src emacs-lisp
     (use-package visual-regexp-steroids
       :bind
       ("C-r" . vr/replace))
   #+end_src

* Setup and options
** Aborting and stopping

   Every once in a blue moon, you actually want out of emacs...

   #+begin_src emacs-lisp
     ;; The default isn't that great actually.
     (global-unset-key (kbd "C-x C-c"))

     ;; Hard to accidentally do, but still easy to hit.
     (global-set-key (kbd "<f11>") 'save-buffers-kill-emacs)
   #+end_src

** Backups

   Backups are disabled. Never had use for them, and the default settings are
   pretty littering.

   #+begin_src emacs-lisp
     (defvar --backup-directory (concat user-emacs-directory "backups"))

     (if (not (file-exists-p --backup-directory))
         (make-directory --backup-directory t))

     (setq backup-directory-alist `(("." . ,--backup-directory)))

     (setq make-backup-files nil      ; backup of a file the first time it is saved.
           backup-by-copying t        ; don't clobber symlinks
           version-control nil        ; version numbers for backup files
           delete-old-versions t      ; delete excess backup files silently
           delete-by-moving-to-trash nil
           kept-old-versions 1        ; oldest versions to keep when a new numbered backup is made (default: 2)
           kept-new-versions 1        ; newest versions to keep when a new numbered backup is made (default: 2)
           auto-save-default nil      ; auto-save every buffer that visits a file
           auto-save-timeout 9000     ; number of seconds idle time before auto-save (default: 30)
           auto-save-interval 900000  ; number of keystrokes between auto-saves (default: 300)
           )
   #+end_src

** Browser setup

   This uses the `chrome-app` command from the dotfiles repo and puts browser
   configuration outside of emacs.

   #+begin_src emacs-lisp
     (setq browse-url-browser-function 'browse-url-generic
           browse-url-generic-program "chrome-app")
   #+end_src

** Clean mode line

   This tries to clean up the modeline as much as possible. I'm honestly not
   sure if it is still needed, but hey.

   Nicely borrowed from a [[http://www.masteringemacs.org/articles/2012/09/10/hiding-replacing-modeline-strings/][Mastering Emacs]] blog post.

   #+begin_src emacs-lisp
     (defvar mode-line-cleaner-alist
       `((paredit-mode . "")
         (lispy-mode . " ()")
         (eldoc-mode . "")
         (abbrev-mode . "")
         (auto-fill-mode "")
         (helm-mode "")
         (magit-auto-revert-mode "")
         (auto-revert-mode "")
         (yas-minor-mode "")
         (undo-tree-mode "")
         (ivy-mode "")

         ;; Major modes
         (js2-mode "js2")
         (javascript-mode "js")
         (help-mode . "")
         (fundamental-mode . "0")
         (python-mode . "py")
         (emacs-lisp-mode . "el")))

     (defun clean-mode-line ()
       (interactive)
       (cl-loop for cleaner in mode-line-cleaner-alist
                do (let* ((mode (car cleaner))
                          (mode-str (cdr cleaner))
                          (old-mode-str (cdr (assq mode minor-mode-alist))))
                     (when old-mode-str
                       (setcar old-mode-str mode-str))
                     ;; major mode
                     (when (eq mode major-mode)
                       (setq mode-name mode-str)))))

     (add-hook 'after-change-major-mode-hook 'clean-mode-line)
   #+end_src

** eshell

   eshell is nice and I am getting into the habit of using it! This defines a
   nice function that lets you drop into a shell in the directory where the
   current buffer is visiting a file.

   #+begin_src emacs-lisp
     (defun eshell-here ()
       "Opens up a new shell in the directory associated with the
     current buffer's file. The eshell is renamed to match that
     directory to make multiple eshell windows easier."
       (interactive)
       (let* ((parent (if (buffer-file-name)
                          (file-name-directory (buffer-file-name))
                        default-directory))
              (height (/ (window-total-height) 3))
              (name   (car (last (split-string parent "/" t)))))
         (split-window-vertically (- height))
         (other-window 1)
         (eshell "new")
         (rename-buffer (concat "*eshell: " name "*"))

         (insert (concat "ls"))
         (eshell-send-input)))

     (global-set-key (kbd "C-x e") 'eshell-here)

     (defun eshell/x ()
       (insert "exit")
       (eshell-send-input)
       (delete-window))

     (setenv "PAGER" "cat")
     (defalias 'e 'find-file)
   #+end_src

** Linum

   This sets up =linum=, but only for programming buffers. =org= gets super
   sad by line numbers for some reason.

   #+begin_src emacs-lisp
     (global-linum-mode 0)
     (setq linum-format " %4d ")

     (defun th-linum-filter ()
       "Only have line numbers when programming"
       (if (derived-mode-p 'prog-mode)
           (linum-mode 1)))

     (add-hook 'find-file-hook 'th-linum-filter)
   #+end_src

** Minibuffer

   Pasting into the minibuffer. Inspired by a [[http://blog.binchen.org/posts/paste-string-from-clipboard-into-minibuffer-in-emacs.html][blog post]] found some time ago.

   #+begin_src emacs-lisp
     (defun th-paste-from-x-clipboard ()
       (interactive)
       (shell-command "echo $(xsel -o)" 1))

     (defun th-paste-in-minibuffer ()
       (local-set-key (kbd "M-y") 'th-paste-from-x-clipboard)
       (local-set-key [mouse-2] 'th-paste-from-x-clipboard))

     (add-hook 'minibuffer-setup-hook 'th-paste-in-minibuffer)
   #+end_src

** mode-line

   https://github.com/ocodo/.emacs.d/blob/master/custom/mode-line-hack.el

   #+begin_src emacs-lisp
     ;; Mode line setup - forked from http://amitp.blogspot.com.au/2011/08/emacs-custom-mode-line.html
     (setq-default
      mode-line-format
      '(; Position, including warning for 80 columns
        (:propertize "%4l:" face mode-line-position-face)
        (:eval (propertize "%3c" 'face
                           (if (>= (current-column) 100)
                               'mode-line-hi-col-face
                             'mode-line-position-face)))
        ; emacsclient [default -- keep?]
        mode-line-client
        "  "
        ; read-only or modified status
        (:eval
         (cond (buffer-read-only
                (propertize " RO " 'face 'mode-line-read-only-face))
               ((buffer-modified-p)
                (propertize " ** " 'face 'mode-line-modified-face))
               (t "    ")))
        "    "
        ; directory and buffer/file name
        (:propertize (:eval (shorten-directory default-directory 30))
                     face mode-line-folder-face)
        (:propertize "%b"
                     face mode-line-filename-face)
        ; narrow [default -- keep?]
        " %n "
        ; mode indicators: vc, recursive edit, major mode, minor modes, process, global
        (vc-mode vc-mode)
        "  %["
        (:propertize mode-name
                     face mode-line-mode-face)
        "%] "
        (:eval (propertize (format-mode-line minor-mode-alist)
                           'face 'mode-line-minor-mode-face))
        (:propertize mode-line-process
                     face mode-line-process-face)
        (global-mode-string global-mode-string)
        "    "
        ; nyan-mode uses nyan cat as an alternative to %p
        (:eval (when nyan-mode (list (nyan-create))))
        ))

     ;; Helper function
     (defun shorten-directory (dir max-length)
       "Show up to `max-length' characters of a directory name `dir'."
       (let ((path (reverse (split-string (abbreviate-file-name dir) "/")))
             (output ""))
         (when (and path (equal "" (car path)))
           (setq path (cdr path)))
         (while (and path (< (length output) (- max-length 4)))
           (setq output (concat (car path) "/" output))
           (setq path (cdr path)))
         (when path
           (setq output (concat ".../" output)))
         output))

     ;; Extra mode line faces
     (make-face 'mode-line-read-only-face)
     (make-face 'mode-line-modified-face)
     (make-face 'mode-line-folder-face)
     (make-face 'mode-line-filename-face)
     (make-face 'mode-line-position-face)
     (make-face 'mode-line-mode-face)
     (make-face 'mode-line-minor-mode-face)
     (make-face 'mode-line-process-face)
     (make-face 'mode-line-hi-col-face)

     (set-face-attribute 'mode-line nil          :foreground "gray60" :background "#333333" :inverse-video nil :box '(:line-width 3 :color "#101010" :style nil))
     (set-face-attribute 'mode-line-inactive nil :foreground "gray80" :background "#1B141F" :inverse-video nil :box '(:line-width 3 :color "#1B141F" :style nil))

     (set-face-attribute 'mode-line-read-only-face nil  :inherit 'mode-line-face          :foreground "#4271ae" :box '(:line-width 3 :color "#4271ae"))
     (set-face-attribute 'mode-line-modified-face nil   :inherit 'mode-line-face          :foreground "#FF0000" :background "#dbdbdb" :box '(:line-width 3 :color "#880000"))
     (set-face-attribute 'mode-line-folder-face nil     :inherit 'mode-line-face          :foreground "gray50")
     (set-face-attribute 'mode-line-filename-face nil   :inherit 'mode-line-face          :foreground "#FABD2F" :weight 'bold)
     (set-face-attribute 'mode-line-position-face nil   :inherit 'mode-line-face)
     (set-face-attribute 'mode-line-mode-face nil       :inherit 'mode-line-face          :foreground "#fe8019")
     (set-face-attribute 'mode-line-minor-mode-face nil :inherit 'mode-line-mode-face     :foreground "gray60")
     (set-face-attribute 'mode-line-process-face nil    :inherit 'mode-line-face          :foreground "#718c00")
     (set-face-attribute 'mode-line-hi-col-face nil     :inherit 'mode-line-position-face :foreground "black" :background "#db6000")
   #+end_src

** Options and settings
#+begin_src emacs-lisp
  (require 's)
  (fset 'yes-or-no-p 'y-or-n-p)
  (setq-default indicate-empty-lines t)


     (fringe-mode 12)
     (setq scroll-step 10)

  (setq debug-on-error nil)

  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (mouse-wheel-mode 1)
  (scroll-bar-mode -1)
  (set-default 'truncate-lines nil)

  (setq mouse-yank-at-point t)

  (setq compilation-read-command nil)

  (setq inhibit-startup-screen t
        initial-scratch-message ";; *scratch*\n\n")

  (setq backup-inhibited t
        make-backup-files nil
        auto-save-default nil)

  (setq backup-by-copying t)

  ;; Save all tempfiles in $TMPDIR/emacs$UID/
  (defconst emacs-tmp-dir
    (format "/tmp/emacs-%s/" (user-uid)))
  (make-directory emacs-tmp-dir t)
  (setq backup-directory-alist
        `(("." . ,emacs-tmp-dir)))
  (setq auto-save-file-name-transforms
        `((".*" ,emacs-tmp-dir t)))
  (setq temporary-file-directory emacs-tmp-dir)

  (setq auto-save-list-file-prefix
        emacs-tmp-dir)

  (setq auto-save-interval 90000
        auto-save-timeout 3600)

  (setq compilation-scroll-output t)

  (defadvice save-buffer (around save-buffer-as-root-around activate)
    "Create non-existing parent directories; sudo to save the current buffer if permissions are lacking."
    (interactive "p")

    ;; Only do any of this if we actually have a fil
    (if (buffer-file-name)
        (progn
          ;; Create the parent directories
          (make-directory (f-dirname (buffer-file-name)) t)

          ;; If the file is not writeable, try
          (if (not (file-writable-p (buffer-file-name)))
              (let ((buffer-file-name (format "/sudo::%s" buffer-file-name)))
                ad-do-it))
          ad-do-it)
      ad-do-it))

  (setq echo-keystrokes 0.4
        standard-indent 4
        tab-always-indent 'complete)

  (setq-default comment-column 42
                fill-column 78
                indent-tabs-mode nil
                tab-width 2
                word-wrap t)


  (put 'downcase-region 'disabled nil)

  (show-paren-mode t)
  (electric-pair-mode t)
  (global-auto-revert-mode t)
  (auto-fill-mode t)
  (auto-save-mode -1)
  (fci-mode 1)
#+end_src
** uniquify

   emacs has this interesting habit of wanting to make new buffers every time
   you visit a new file. This is silly, and this plugin fixes that.

   #+begin_src emacs-lisp
     (require 'uniquify)
     (setq uniquify-buffer-name-style 'forward)
   #+end_src

** Window management

   Sets up quicker window management bindings.

*** Settings

    These things set in which directions windows split.

   #+begin_src emacs-lisp
     ;; Try to make emax split vertically when possible
     (setq split-height-threshold 100)
     (setq split-width-threshold 160)

     ;; So that (compile) and other commands re-use already open buffers in other
     ;; frames. Really useful when using dual monitors.
     (setq display-buffer-reuse-frames t)
   #+end_src

*** Killing windows

    I kill windows all the time. So often that I want to be able to do it
    super quickly. So, =C-q= comes into play!

    #+begin_src emacs-lisp
      (defun th-kill-window ()
        "Kill the window. If it's the last one in the frame and the server is running, kill the frame."
        (interactive)
        (if (and (one-window-p) (server-running-p))
            (progn
              (when (buffer-file-name)
                (save-buffer))
              (delete-frame))
          (progn
            (delete-window)
            (save-excursion
              (balance-windows)))))

      (global-set-key (kbd "C-q") 'th-kill-window)
    #+end_src

*** Hydra switching

    Hydras are great, especially for these kinds of things.
    http://oremacs.com/2015/02/04/pre-hydra-post/

    #+begin_src emacs-lisp
      (defhydra hydra-window ()
         "window"
         ("h" windmove-left)
         ("j" windmove-down)
         ("k" windmove-up)
         ("l" windmove-right)
         ("H" shrink-window-horizontally)
         ("J" shrink-window)
         ("K" enlarge-window)
         ("L" enlarge-window-horizontally)
         ("f" projectile-find-file "file" :color blue)
         ("p" projectile-switch-project "project" :color blue)
         ("b" balance-windows "balance")
         ("e" next-error "next error")
         ("E" previous-error "prev error")
         ("M-e" first-error "first error")
         ("n" new-frame "new frame" :color blue)
         ("a" (lambda ()
                (interactive)
                (ace-window 1)
                (add-hook 'ace-window-end-once-hook
                          'hydra-window/body)
                (throw 'hydra-disable t))
          "ace")
         ("s" (lambda ()
                (interactive)
                (split-window-right)
                (windmove-right))
          "vert")
         ("z" (lambda ()
                (interactive)
                (split-window-below)
                (windmove-down))
          "horz")
         ("w" (lambda ()
                (interactive)
                (ace-window 4)
                (add-hook 'ace-window-end-once-hook
                          'hydra-window/body)
                (throw 'hydra-disable t))
          "swap")
         ("t" transpose-frame "'")
         ("d" (lambda ()
                (interactive)
                (ace-window 16)
                (add-hook 'ace-window-end-once-hook
                          'hydra-window/body)
                (throw 'hydra-disable t))
          "del")
         ("o" delete-other-windows "one" :color blue)
         ("i" ace-maximize-window "ace-one" :color blue)
         ("q" nil "cancel"))

      (defun th-copy-or-hydra-window ()
        "M-w without a region is terrible. Make it useful instead."
        (interactive)
        (if (use-region-p)
            (kill-ring-save (region-beginning) (region-end))
          (hydra-window/body)))

      (global-set-key (kbd "M-w") 'th-copy-or-hydra-window)

      ;; Also disable the old ones so that I stop using them
      (defun th-disabled-key ()
        (interactive)
        (message "This key is disabled. Use M-w."))

      (global-set-key (kbd "C-x 1") 'th-disabled-key)
      (global-set-key (kbd "C-x 2") 'th-disabled-key)
      (global-set-key (kbd "C-x 3") 'th-disabled-key)
   #+end_src

*** Quick switching

    Even though the hydra above is great, there are some things we just do all
    the time - switching between the windows.

    #+begin_src emacs-lisp
      (global-set-key (kbd "C-x h") 'windmove-left)
      (global-set-key (kbd "C-x j") 'windmove-down)
      (global-set-key (kbd "C-x k") 'windmove-up)
      (global-set-key (kbd "C-x l") 'windmove-right)
    #+end_src

* Work

  Work-specific things that are in other repositories because secrets.

  #+begin_src emacs-lisp
    (require 'f)
    (let ((work-path "~/spotify/elisp/"))
      (when (f-dir? work-path)
        (add-to-list 'load-path work-path)
        (require 'payments)))
  #+end_src

* Theme fixes

  Because of how emacs loads things, some of the fixes need to be applied
  really late. Like, linum has not been loaded when the theme loading
  happens. As such, we place it here.

  #+begin_src emacs-lisp
    (th-fix-darktooth)
  #+end_src

If only I was not one of those so very fond of tinkering and dotfiling, I
might've actually gotten things done. That would have been something, right?
