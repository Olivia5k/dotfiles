#+TITLE: go-mode configuration and extensions
#+AUTHOR: Lowe Thiderman
#+EMAIL: lowe.thiderman@gmail.com

These are my go tricks. They are opinionated, but hopefully pretty useful even
for someone who isn't me!

To use this file, put a snippet like the one below into your emacs source.

#+begin_src emacs-lisp :tangle no
  (require 'org)
  (org-babel-load-file "/path/to/go-mode.org")
#+end_src

You will need [[https://github.com/jwiegley/use-package][use-package]] for this to work.

If you have [[https://github.com/abo-abo/hydra][hydra]] installed, the [[https://godoc.org/golang.org/x/tools/cmd/guru][guru]] command of ~C-c C-o~ will become a hydra
rather than a very tricky to use keymap.

* Packages and hooks

  Load the base go-mode package and set up the hooks.
  Also installs the libraries that these tricks depend on.

  #+begin_src emacs-lisp
    (use-package go-mode
      :bind
      ("C-c r"   . go-rename)
      ("C-c i"   . go-goto-imports)
      ("C-c C-i" . go-remove-unused-imports)
      ("C-c d"   . godoc)

      :init
      (defun th/go-hook ()
        (add-hook 'before-save-hook 'gofmt-before-save)
        (set (make-local-variable 'company-backends) '(company-go))
        (company-mode)
        (flycheck-mode 1))

      :config
      (require 'go-guru)
      (add-hook 'go-mode-hook 'th/go-hook)
      (add-hook 'go-mode-hook 'go-eldoc-setup))

    (use-package company)
    (use-package company-go)
    (use-package go-eldoc)

    ;; These are libraries used within
    (use-package dash)
    (use-package f)
    (use-package s)
  #+end_src

* goto functions

  #+begin_src emacs-lisp
    ;; These were all moved into upstream! Yay open source <3
    (define-key go-mode-map (kbd "C-c g") 'go-goto-map)
  #+end_src

* Coverage functions

  Shows coverage for the current go file. Deletes other windows.

  #+begin_src emacs-lisp
    (defun th/go-coverage ()
      "Toggle coverage mode for the current buffer"
      (interactive)

      (save-excursion
        (let ((bn (buffer-name)))
          (if (s-contains? "<gocov>" bn)
              (progn
                (windmove-left)
                (th/go-test-buffer-p))

            (if (s-contains? "_test.go" bn)
                (progn
                  (windmove-left)
                  (th/go-coverage-p))
              (windmove-right)
              (if (not (s-contains? "<gocov>" (buffer-name)))
                  (progn
                    (windmove-left)
                    (th/go-coverage-p))
                (windmove-left)
                (th/go-test-buffer-p)))))))

    (defun th/go-coverage-p ()
      (delete-other-windows)
      (go-coverage (concat (projectile-project-root) "cover.out")))

    (define-key go-mode-map (kbd "C-c c") 'th/go-coverage)
  #+end_src

* Test file view

  Brings up a split view of a single file and it's corresponding test file.
  The test file will be created if it does not already exist.

  #+begin_src emacs-lisp
    (defun th/go-test-buffer-p ()
      (let* ((bname (buffer-file-name))
             (left "")
             (right ""))

        (if (s-suffix? "_test.go" bname)
            (setq left (th/go-alternate-file bname)
                  right bname)
          (setq left bname
                right (th/go-alternate-file bname)))

        (find-file left)
        (delete-other-windows)
        (split-window-horizontally)
        (windmove-right)
        (find-file right)))

    (defun th/go-test-buffer ()
      (interactive)
      (th/go-test-buffer-p))

    (defun th/go-test-buffer-split (file)
      ;; If we happen to be on the test file when splitting, go left once
      (when (th/go-test-file-p (buffer-file-name (get-buffer helm-current-buffer)))
        (windmove-left))

      (let ((fn (format "%s/%s.go" (projectile-project-root) file)))
        (split-window-below)
        (find-file fn)
        (windmove-right)
        (split-window-below)
        (find-file (th/go-alternate-file fn))
        (balance-windows)))

    (defun th/go-alternate-file (fn)
      "If fn is code, return path to test file and vice versa"

      (if (s-suffix? "_test.go" fn)
          (s-replace "_test.go" ".go" fn)
        (s-replace ".go" "_test.go" fn)))

    (defun th/go-test-file-p (&optional fn)
      "Returns boolean if the file name given is a test file"
      (s-contains? "_test.go"
                   (if (not fn)
                       (buffer-file-name)
                     fn)))

    (defun th/go-alternate ()
      "Go to the alternate file; code or test."
      (interactive)
      (find-file (th/go-alternate-file (buffer-name))))

    (define-key go-mode-map (kbd "C-c a") 'th/go-alternate)
  #+end_src

* Single test execution

  Helper function that lets you execute a single test rather than the entire
  suite. Run with =C-M-x= on a test file. When run in a non-test file, the
  most recently executed test will be run again.

  #+begin_src emacs-lisp
    (defun th/go-get-test-above ()
      "Gets the name of the test above point"
      (save-excursion
        (re-search-backward "^func \\(Test\\|Example\\)" nil t)
        (forward-word 2)
        (thing-at-point 'symbol t)))

    (defvar th/go-last-single-test "go test" "The last single test command that was run")

    (defun th/go-single-test ()
      "If in test file, run the test above point. If not, run the last run test."
      (interactive)
      (projectile-save-project-buffers)
      (when (th/go-test-file-p)
        (setq th/go-single-test (format "go test -v -run %s" (th/go-get-test-above))))
      (compile th/go-single-test))

    (define-key go-mode-map (kbd "C-M-x") 'th/go-single-test)
  #+end_src

* Snippet helpers

  These are functions used inside of yas.

  #+begin_src emacs-lisp
    (defun th/go-select-type-signature ()
      "Used to make a selection of what type to attach a new func to"
      (save-excursion
        (let* ((empty "<none>")
               (type (completing-read
                      "Type: "
                      (append (list empty)
                              (go--get-types)))))
          (if (not (s-equals? type empty))
              (format
               " %s "
               (go--convert-type-name-to-receiver
                (car (s-split " " type))))
            " "))))
  #+end_src

* Compiling and executing

  Helper functions that make compiling and viewing the compilation log
  simpler.

  #+begin_src emacs-lisp
    (defun th/go-test ()
      (interactive)
      (projectile-save-project-buffers)
      ;; The server compile command should run in the root
      (compile "go test -coverprofile=cover.out"))

    (define-key go-mode-map (kbd "C-c C-c") 'th/go-test)

    (defun th/go-server-compile ()
      (interactive)
      (projectile-save-project-buffers)
      ;; The server compile command should run in the root
      (with-current-buffer (th/go-main-file-buffer)
        (compile "go build -v")))

    (defun th/go-main-file ()
      "Returns the main go file of the project"
      (let ((path (projectile-project-root)))
        (concat path (format "%s.go" (f-base path)))))

    (defun th/go-main-file-buffer ()
      "Returns the buffer of the main go file of the project"
      (get-file-buffer (th/go-main-file)))

    (defun th/go-modules ()
      "Get the paths to all modules found in the project"
      (let ((path (projectile-project-root)))
        (cdr ;; Remove the ./
         (-uniq
          (-map
           (lambda (fn)
             ;; Add ./ so that go considers the modules as local and not remote
             (concat "./" (f-dirname fn)))
           (-filter
            ;; Return a list with all go files
            (lambda (fn) (s-contains? ".go" fn))
            (projectile-current-project-files)))))))

    (define-key go-mode-map (kbd "C-c C-k") 'popwin:close-popup-window)

  #+end_src

* Docstring manipulation

  Update the function name of the docstring for the function you are
  visiting. Useful when renaming functions.

  #+begin_src emacs-lisp
    (defun go-update-docstring ()
      "Update (or create) the docstring function name of the current function.

    Designed to be called from hooks.

    Will not update tests (beginning with Test/Example) or private functions (lowercase)."
      (interactive)

      ;; Only run this hook when in go mode
      (when (and nil (eq major-mode 'go-mode))
        (save-excursion
          (let ((fn (go--function-name)))
            (when (go--should-generate-docstring-p fn)
              (go-goto-docstring)
              ;; Check if we need to update anything
              (when (and
                     (not (looking-at "$")) ;; If at the end of the line, the name has already been generated.
                     (not (looking-at (format "%s " fn)))) ;; If already looking at the correct name, then nothing changed.
                (kill-word 1)
                (insert fn)
                ;; If we updated and are at the end of the line, add a space.
                (if (looking-at "$")
                    (insert " ")
                  (forward-char 1))))))))

    (defun go--should-generate-docstring-p (func-name)
      "Check if we should update the docstring or not"
      (and
       ;; If the function name is a test, skip it.
       (not (or (s-prefix? "Test" func-name)
                (s-prefix? "Example" func-name)
                (s-prefix? "Benchmark" func-name)))
       ;; If the function name is lowercase, then we don't need a docstring
       (not (s-lowercase? (s-left 1 func-name)))
       ;; We need to be at the definition line
       (and
        (progn
          (beginning-of-line)
          (looking-at "^func "))
        (progn
          (end-of-line)
          (backward-char 1)
          (looking-at "{$")))))

    (defun go-delete-backward-char ()
      "runs `delete-backward-char' and also the docstring hook"
      (interactive)
      (delete-backward-char 1)
      (go-update-docstring))

    (defun go-delete-char ()
      "runs `delete-char' and also the docstring hook"
      (interactive)
      (delete-char 1)
      (go-update-docstring))

    (add-hook 'post-self-insert-hook 'go-update-docstring)
    (define-key go-mode-map (kbd "DEL") 'go-delete-backward-char)
    (define-key go-mode-map (kbd "C-d") 'go-delete-char)

  #+end_src

* Refactoring

  These are inspired by [[https://github.com/magnars/js2-refactor.el][js2-refactor]].

** Wrap in if

   Wraps the current line in an if statement. Places point just after ~if~.

   #+begin_src emacs-lisp
     (defun go-refactor-wrap-if ()
       (interactive)
       (go--refactor-wrap "if ")
       (forward-char 3))

     (define-key go-mode-map (kbd "C-c C-m i") 'go-refactor-wrap-if)
   #+end_src

** Wrap in loop

   Wraps the current line in a for loop. Places point just after ~for~.

   #+begin_src emacs-lisp
     (defun go-refactor-wrap-for ()
       (interactive)
       (go--refactor-wrap "for ")
       (forward-char 4))

     (define-key go-mode-map (kbd "C-c C-m f") 'go-refactor-wrap-for)
   #+end_src

** Wrap in goroutine

   Wraps the current line in a for loop. Places point just after ~for~.

   #+begin_src emacs-lisp
     (defun go-refactor-wrap-goroutine ()
       (interactive)
       (go--refactor-wrap "go func()")

       ;; Also add the parenthesis at the end
       (save-excursion
         (end-of-line)
         (backward-char 1)
         (forward-list)
         (insert "()"))

       (forward-char 8))

     (define-key go-mode-map (kbd "C-c C-m g") 'go-refactor-wrap-goroutine)
   #+end_src

** TODO Wrap in err if
** TODO Raise
** TODO Extract variable
** TODO Extract function
** TODO Type migration
** TODO Toggle error return

   Toggles if the method returns an error or not. Adds or removes the `err`
   variable to any return statements in the current function.

** TODO Toggle error assign

   Toggles between ~err~/~_~ for the current assigment.

** Method receiver

   Adds ~go-refactor-method-receiver~ (bound to =C-c C-m r=), a function to
   change the type signature of the current method.

   Calling it will present a selection of all available types in the current
   file. Selecting one of them will change the receiver to the new one, so
   selecting /User/ will set the receiver to be ~(u *User)~.

   If there was a previous type (e.g. ~(s *Server)~) all instances of ~s~ will
   be replaced with ~u~ inside of the method.

   The special type ~<none>~ will remove the receiver. This will not change the
   ~s~ in the example above.

   #+begin_src emacs-lisp
     (defun go-refactor-method-receiver ()
       "Changes or removes the method receiver of the current function.

     A choice between all the types in the current file are
     interactively presented. Also presented is an item `<none>',
     which will remove the receiver if there is one.

     If there was a receiver and a new one is chosen,"
       ;; TODO(thiderman): We need to undo twice to undo this. Investigate.
       (interactive)
       (save-excursion
         (go-goto-function t)
         (forward-char 5)

         (let*
             ((empty "<none>")
              (current-var
               (save-excursion
                 (forward-char 1)
                 (thing-at-point 'symbol t)))
              (current-type
               (save-excursion
                 (forward-char 1)
                 (forward-word 2)
                 (thing-at-point 'symbol t)))
              (type (completing-read
                     "Type: "
                     (append (go--get-types (buffer-file-name) current-type)
                             (list empty))))
              (receiver (when (not (s-equals? type empty))
                          (go--convert-type-name-to-receiver
                           (car (s-split " " type))))))

           (cond
            ;; If we are looking at an opening parenthesis, there is already a method receiver
            ((looking-at "(")
             ;; Firstly, store the current receiver variable name.


             ;; Then, delete the existing one.
             (delete-region
              (point)
              (save-excursion
                (forward-list 1)
                (point)))
             ;; If we do not have a receiver (i.e. we chose 'empty) we should
             ;; delete the extra space.
             (if (not receiver)
                 (delete-char 1)
               ;; If there was a receiver previously and we set a new one, update the
               ;; variable name.
               (insert receiver)

               ;; And also update the variable name inside of the function.
               (when (and current-var receiver)
                 (go--refactor-symbol-in-function
                  current-var
                  (s-downcase (s-left 1 type))))))
            ((and (not (looking-at "(")) receiver)
             ;; There is no receiver, but we are adding one. Just insert it.
             (insert (format "%s " receiver)))))))

     (defun go--refactor-symbol-in-function (from to)
       "Changes instances of the symbol `from' into `to'.

     Assumes that point is on line defining the function we are replacing in."
       (save-excursion
         (beginning-of-line)
         (let ((start
                (save-excursion
                  (forward-line -1)
                  (point)))
               (end
                (save-excursion
                  ;; TODO(thiderman): Make a method that reliably moves to opening brace.
                  (end-of-line)
                  ;; In case of trailing whitespace...
                  (search-backward "{")
                  (forward-list 1)
                  (backward-char 1)
                  (point))))

           (replace-string from to t start end))))

     (define-prefix-command 'go-refactor-map)
     (define-key go-mode-map (kbd "C-c C-m") 'go-refactor-map)

     (define-key go-refactor-map (kbd "r") 'go-refactor-method-receiver)
   #+end_src
** Refactoring helper methods
*** Wrapper helpers

    #+begin_src emacs-lisp
      (defun go--refactor-wrap (prefix)
        "Wraps the current line or region or statement in a templated statement.

      If the current line ends in an opening brace, the entire
      statement until that brace's end will be wrapped.

      Point ends up on the beginning of the templated statement."
        (interactive)
        (save-excursion
          (let* ((pos (go--region-or-lines))
                 (beg (car pos))
                 (end (cadr pos)))
            (kill-region beg end)
            (indent-according-to-mode)
            (insert (format "%s {}" prefix))
            (backward-char 1)
            (newline-and-indent)
            (yank)))

        (beginning-of-line-text)

        ;; Indent the things we just wrapped
        (indent-region
         (point)
         (save-excursion
           (end-of-line)
           (backward-char 1)
           (forward-list)
           (point)))))

      (defun go--region-or-lines ()
        "Operate or regions or lines"

        (let (beg end)
          (if (and mark-active (> (point) (mark)))
              (exchange-point-and-mark))
          (setq beg (save-excursion
                      (back-to-indentation)
                      (point)))
          (if mark-active
              (exchange-point-and-mark))
          ;; If we're on a line that ends on an opening brace, set the end to
          ;; be the outside of that brace.
          (setq end
                (save-excursion
                  (if (progn (end-of-line)
                             (backward-char 1)
                             (looking-at "{"))
                      (progn
                        (forward-list)
                        (point))
                    (line-end-position))))
          (list beg end)))
    #+end_src

*** Type helper methods

   #+begin_src emacs-lisp
     (defun go--convert-type-name-to-receiver (tn)
       "Converts from the string \"Type\" to \"(t *Type)\""
       (format "(%s *%s)" (s-downcase (s-left 1 tn)) tn))

     (defun go--get-types (&optional file-name skip-type)
       "Return a list of all the types found in the current file.

     The strings returned are based on all lines that begin with
     '^type'. The letters 'type ' and the ending ' {' are both
     removed.

     If `skip-type' is provided, that type will not be included in the resulting list."

       (save-excursion
         (let ((fn (or file-name (buffer-file-name))))
           (-map
            (lambda (s) (s-chop-suffix " {" (s-chop-prefix "type " s)))
            (-filter
             (lambda (s)
               (if skip-type
                   ;; If skip-type is provided, also filter out that line
                   (and (s-prefix? "type " s)
                        (not (s-prefix? (format "type %s " skip-type) s)))
                 ;; Otherwise just return lines that start with "type"
                 (s-prefix? "type " s)))

             ;; Does emacs really don't have a cleaner way of getting lines in a
             ;; file? :/
             (with-temp-buffer
               (insert-file-contents fn)
               (split-string (buffer-string) "\n" t)))))))

   #+end_src

* Debug toggler

  Touch or remove the =toggle/debug= file. Can be used in applications to
  easily increase the log level or similar operations.

  #+begin_src emacs-lisp
    (defun go-toggle-debug ()
      "Toggle the toggle/debug file"
      (interactive)
      (let* ((dir (concat (projectile-project-root) "toggle/"))
             (toggle "debug")
             (action "Toggled")
             (fn (concat dir toggle)))
        ;; Create the directory if it doesn't already exist
        (when (not (f-directory? dir))
          (make-directory dir))

        ;; Toggle the existence of the file
        (if (f-file? fn)
            (progn
              (f-delete fn)
              (setq action "Disabled"))
          (with-temp-buffer
            (write-file fn))
          (setq action "Enabled"))
        (message "%s %s" action toggle)))

    (define-key go-mode-map (kbd "C-c M-d") 'go-toggle-debug)
  #+end_src

* Server runner

  Helper functions to run the executable that the current project produces.
  * =C-c s c= compiles the server
  * =C-c s s= starts or restarts the server
  * =C-c s b= visits the buffer with the output from the process

  One caveat is that the code currently assumes that you have a file called
  =<project-name>.go=.

  #+begin_src emacs-lisp
    ;; TODO: Make the argument part configurable
    (defun th/go-server-start ()
      "Start the server for the app"
      (interactive)
      (let* ((root (projectile-project-root))
             (name (f-base root))
             (procname (format "%s-server" name)))

        ;; If the server is already running, stop it; effectively making this a restart.
        (when (get-process procname)
          (th/go-server-stop))

        (start-process
         procname
         (format "*%s-server*" name)
         (concat root name)
         "server")

        ;; (set-process-filter proc 'th/go-server-insertion-filter)
        (message "Started %s server" name)))

    (defun th/go-server-stop ()
      "Stop the server for the app"
      (interactive)
      (let* ((name (f-base (projectile-project-root))))
        (delete-process
         (format "*%s-server*" name))
        (message "Stopped %s server" name)))

    ;; TODO: Move this to a non-golang place
    (defun th/npm-server-start ()
      "Start the server for the app"
      (interactive)
      (let* ((root (projectile-project-root))
             (name (format "%s-npm" (f-base root)))
             (procname (format "%s-server" name))
             (procbuffer (format "*%s*" procname))
             (dir (concat root "js/")))

        ;; If the server is already running, stop it; effectively making this a restart.
        (when (get-process procname)
          (th/npm-server-stop))

        (let ((default-directory dir))
          (start-process procname procbuffer "npm" "run" "dev"))

        (message "Started %s npm server" name)))

    (defun th/npm-server-stop ()
      "Stop the server for the app"
      (interactive)
      (let* ((name (f-base (projectile-project-root))))
        (delete-process
         (format "*%s-npm-server*" name))
        (message "Stopped %s server" name)))

    (defun th/go-server-buffer ()
      "Stop the server for the app"
      (interactive)
      (let* ((name (f-base (projectile-project-root))))
        (switch-to-buffer (format "*%s-server*" name))))

    ;; (defun th/go-server-insertion-filter (proc string)
    ;;   (with-current-buffer (process-buffer proc)
    ;;     ;; Insert the text, advancing the process marker.
    ;;     (goto-char (process-mark proc))
    ;;     (insert (format "Hehe <%s>" string))
    ;;     (set-marker (process-mark proc) (point))
    ;;     (goto-char (point-max))))

    (let ((m (define-prefix-command 'go-server-map)))
      (define-key m (kbd "s") 'th/go-server-start)
      (define-key m (kbd "k") 'th/go-server-stop)
      (define-key m (kbd "b") 'th/go-server-buffer)
      (define-key m (kbd "c") 'th/go-server-compile)
      (define-key m (kbd "n") 'th/npm-server-start))

    (define-key go-mode-map (kbd "C-c s") 'go-server-map)
  #+end_src

* go-guru hydra

  Since there are so many commands to the guru, I feel like adding them to
  a hydra makes quite a lot of sense!

  #+begin_src emacs-lisp
    ;; Only do this when hydra is available
    (when (require 'hydra nil 'noerror)
      (define-key
        go-mode-map
        (kbd "C-c C-o")
        (defhydra th/go-guru (:exit t)
          "Guru commands"
          ("d" go-guru-describe "describe")
          ("f" go-guru-freevars "freevars")
          ("i" go-guru-implements "implements")
          ("c" go-guru-peers "peers (channels)")
          ("r" go-guru-referrers "referrers")
          ("j" go-guru-definition "definition")
          ("p" go-guru-pointsto "pointsto")
          ("s" go-guru-callstack "callstack")
          ("e" go-guru-whicherrs "whicherrs")
          ("<" go-guru-callers "callers")
          (">" go-guru-callees "callees")
          ("x" go-guru-expand-region "expand-region"))))
  #+end_src
