#!/usr/bin/zsh
# zshrc by Lowe Thiderman (lowe.thiderman@gmail.com)

if [[ "$TERM" != "dumb" ]] && [[ $(echotc Co) = 256 ]]; then
  # Shell syntax highlighting, in realtime.
  source $ZSHCONFDIR/modules/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh

  export ZSH_HIGHLIGHT_STYLES[alias]='fg=87,bold'
  export ZSH_HIGHLIGHT_STYLES[command]='fg=103,bold'
  export ZSH_HIGHLIGHT_STYLES[hashed-command]='fg=103,bold'
  export ZSH_HIGHLIGHT_STYLES[precommand]='fg=110,bold'
  export ZSH_HIGHLIGHT_STYLES[builtin]='fg=65,bold'
  export ZSH_HIGHLIGHT_STYLES[function]='fg=215,bold'
  export ZSH_HIGHLIGHT_STYLES[path]='fg=68,bold'
  export ZSH_HIGHLIGHT_STYLES[assign]='fg=43'

  export ZSH_HIGHLIGHT_STYLES[single-hyphen-option]='fg=87'
  export ZSH_HIGHLIGHT_STYLES[double-hyphen-option]='fg=132'
  export ZSH_HIGHLIGHT_STYLES[single-quoted-argument]='fg=107,bold'
  export ZSH_HIGHLIGHT_STYLES[double-quoted-argument]='fg=107,bold'

  # Really extensive LS_COLORS.
  if (( $+commands[dircolors] )) ; then
    eval $(dircolors -b $ZSHCONFDIR/modules/LS_COLORS/LS_COLORS)
  fi
fi

if [[ $OSTYPE != darwin* ]]; then
  ls_options+=( --group-directories-first )
fi

alias ls='command ls -bhv '${ls_options:+"${ls_options[*]}"}
alias l='ls -lbhv '${ls_options:+"${ls_options[*]}"}

# grml sets ag to be aliased to "sudo apt-get". This is annoying when you want
# to use the silver searcher, whose binary is called, you guessed it, ag.
if alias ag &> /dev/null; then
  unalias ag
fi

alias as="sudo apt-cache search"
alias ai="sudo apt-get install"

alias zz="source $ZSHRC"

alias docker="sudo docker"

alias e="emacsclient --alternate-editor='vim' -t"
alias bell='echo -en "\007"'

alias z=keyboard-setup

alias -g G="| grep -i"
alias -g T="| tail"
alias -g S="| sort"
alias -g SH="| sort -h"
alias -g SU='| sort -u'
alias -g SN='| sort -n'
alias -g W="| wc -l"
alias -g E="&| exit"
alias -g EE="&& exit"

# 1. Normal cd
# 2. Create a directory if it doesn't exist
# 3. If target is a file, go to parent directory
function cd () {
  local opt=""
  if [[ ${+2} = 0 ]]; then
    if [[ -f $1 ]]; then
      builtin cd $opt $1:h
    else
      if ! builtin cd $opt $1 && [[ $#@ -eq 1 && ! -d $1 ]]; then
        echo -En "cd: $1 doesn't exist, do you want to create it? [y/N] "
        read -sq && mkcd $1
      fi
    fi
  else
    if [[ -z $3 ]]; then
      builtin cd $opt "$1" "$2"
    else
      echo cd: too many arguments
    fi
  fi
}

mkdir -p $XDG_DATA_HOME/zsh
a=( ${^fpath}/chpwd_recent_dirs(N) )
if (( $#a > 0 )); then
  autoload -Uz chpwd_recent_dirs cdr add-zsh-hook
  add-zsh-hook chpwd chpwd_recent_dirs

  alias cdl="cdr -l"

  zstyle ':completion:*:*:cdr:*:*' menu selection
  zstyle ':chpwd:*' recent-dirs-file $XDG_DATA_HOME/zsh/cdr
  zstyle ':chpwd:*' recent-dirs-max 21
fi

# Edit current commandline with actual editor
autoload -U   edit-command-line
zle -N        edit-command-line
bindkey '^[e' edit-command-line

# Disable Ctrl-q/s flow control.
stty -ixon

# Git setup
# Committing / General
alias ga='git add'
alias gs='git status'
alias s='git status --short'
alias gc='git commit'
alias gca='gc --amend'
alias gp='git push'

alias gu="git pull"

# Branching (only really useful with -v, really)
alias gb='git branch -v'
alias gba='git branch -av'
alias gbv='git branch -vv'
alias gsb='git show-branch'

# Fetching
alias gf='git fetch'
function gfa {
    if ! git config -l | grep "remote.origin.fetch" | grep refs/pull &> /dev/null; then
        git config --add remote.origin.fetch "+refs/pull/*/head:refs/remotes/origin/pr/*"
        print -P "%F{71}%BAuto%b%f: Set up PR fetching"
    fi
    git fetch --all
}

# Remotes
alias gre='git remote -v'
alias gra='git remote add'

# Stashing
alias gt="git stash"
alias gtl="git stash list"
alias gtp="git stash pop"

# Submodules
alias gsa='git submodule add'
alias gsi='git submodule update --init'
alias gsu='git submodule update'

# Diffing
alias gd='git diff'
alias gdh='git diff HEAD'

# Merging
alias gm="git merge"
alias gls="git ls-files"
alias glsu="git ls-files --unmerged"
alias glsm="git ls-files --modified"
alias glss="git ls-files --stage"
alias glsd="git ls-files --deleted"
alias grb='git rebase'

# Logging
if (( $+commands[tig] )) ; then
  alias gl='tig'
else
  alias gl='git lg'
fi

alias glg='git lgg'
alias gll='git log --abbrev-commit --decorate --stat'
alias glc="git shortlog --summary --numbered"
alias glr="git reflog"

alias gau='git update-index --assume-unchanged'

# Relatively go up to a repository root
function gr() {
  cur=$PWD
  found=false
  is_in=false
  if [[ -n "$1" ]]; then
    msg="zle -M"
  else
    msg="echo"
  fi

  if [[ -r "$cur/.git" ]]; then
    is_in=true
    cur=${cur%/*}
  fi

  until [[ -z "$cur" ]]; do
    if [[ -r "$cur/.git" ]]; then
      found=true
      break
    fi
    cur=${cur%/*}
  done

  if $found; then
    if $is_in; then
      ${(z)msg} "In submodule: going to superproject"
    fi

    [[ -n "$1" ]] && pushd -q $cur || cd $cur
  elif [[ -d "$PWD/.git" ]]; then
    ${(z)msg} "Already at project root"
  else
    ${(z)msg} "Error: Currently not in a git repository"
  fi
}

function _find_git_root() {
  # Helper that finds the real git root.
  # Useful when relatively needing data from a new-style submodule.
  cur=${1:-$PWD}
  until [[ -z "$cur" ]]; do
    if [[ -f "$cur/.git" ]]; then
      # New-style submodules are files
      rel=${${(s: :)"$(<$cur/.git)"}[2]}
      if [[ "$rel" =~ "^../" ]]; then
        # Relative relative! D:
        combined="$cur/$rel"
        git_root=$combined:A
      else
        # Absolute relative.
        git_root=$rel
      fi

      break
    elif [[ -d "$cur/.git" ]]; then
      git_root="$cur/.git"
      break
    fi
    cur=${cur%/*}
  done

  if [[ "$git_root" = "/" ]]; then
    git_root=""
  fi
}

# Set up hub as an alias for git if it is installed
if (( $+commands[hub] )) ; then
  alias git=hub
  if type compdef >/dev/null; then
    compdef hub=git
  fi
fi

# Disable git prompt
zstyle ':vcs_info:*' enable NONE

# Make a neat prompt!
for x in user at host path percent; do
  zstyle ":prompt:grml:left:items:$x" post '%f%b'
done

color=143 # Green
if [[ $UID == 0 ]] ; then
    color=9 # Root red
elif [[ $HOST =~ 'dragon' ]]; then
    color=177 # Purple
fi

for x in user at host; do
  zstyle ":prompt:grml:left:items:$x" pre "%B%F{$color}"
done

zstyle ':prompt:grml:left:items:path' pre '%B%F{68}'
zstyle ':prompt:grml:left:items:path' token '%1~ '
zstyle ':prompt:grml:left:items:percent' pre "%B%F{245}"
zstyle ':prompt:grml:left:items:percent' token "> "
zstyle ':prompt:grml:left:items:vcs' pre '$VENV_PROMPT'
zstyle ':prompt:grml:right:items:sad-smiley' pre '%B%F{196}'

# fzf for the win!
[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh

# z is a pretty cool guy. eh jumps dirs and doesn't afraid of anything
export _Z_CMD="j"
[ -f ~/git/z/z.sh ] && source ~/git/z/z.sh

# wow such shibe. https://github.com/thiderman/doge
if (( $+commands[doge] )) ; then
  #doge
fi

if [[ "$TERM" == "dumb" ]]; then
  prompt off
  PS1='> '
fi
